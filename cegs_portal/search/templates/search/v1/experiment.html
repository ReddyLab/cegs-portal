{% extends "base.html" %}
{% load static i18n %}

{% block css %}
{{ block.super }}
<link href="{% static 'css/nouislider.min.css' %}" rel="stylesheet">
{% endblock %}

{% block javascript %}
{{ block.super }}
<script type="text/javascript" src="{% static 'js/lodash.min.js' %}"></script>
<script type="text/javascript" src="{% static 'js/nouislider.min.js' %}"></script>
<script type="text/javascript" src="https://d3js.org/d3.v7.min.js"></script>
{% endblock %}

{% block title %}Experiment{% endblock %}
{% block content %}
    <div class="max-w-5xl">
        <div class="text-2xl font-bold">{{ experiment.name }}</div>
        <table class="data-table">
            <tr><th>Description</th><td>{{ experiment.description }}</td></tr>
            <tr><th>Assay</th><td>{{ experiment.experiment_type }}</td></tr>
            <tr><th>Cell Lines</th><td>{{ experiment.cell_lines|join:", " }}</td></tr>
            <tr><th>Tissue Types</th><td>{{ experiment.tissue_types|join:", " }}</td></tr>
            <tr><th>Assemblies</th><td>{{ experiment.assemblies|join:", " }}</td></tr>
        </table>

        {% if experiment.data_files.all|length > 0 %}
        <div>
            <div class="text-xl font-bold">Data Files</div>
            {% for file in experiment.data_files.all %}
            <table class="data-table">
                <tr><th>File Name</th><td>{{ file.filename }}</td></tr>
                <tr><th>Description</th><td>{{ file.description }}</td></tr>
                <tr><th>Cell Lines</th><td>{{ file.cell_lines.all|join:", " }}</td></tr>
                <tr><th>Tissue Types</th><td>{{ file.tissue_types.all|join:", " }}</td></tr>
                <tr><th>Assembly</th><td>{{ file.ref_genome }}.{{ file.ref_genome_patch|default:"0" }}</td></tr>
            </table>
            {% endfor %}
        </div>
        {% endif %}

        {% if experiment.other_files.all|length > 0 %}
        <div>
            <div class="text-xl font-bold">Other Files</div>
            {% for file in experiment.other_files.all %}
            <table class="data-table">
                <tr><th>File Name</th><td>{{ file.filename }}</td></tr>
                <tr><th>Description</th><td>{{ file.description }}</td></tr>
                <tr><th>Location</th><td><a href="{{ file.url }}">{{ file.url }}</a></td></tr>
            </table>
            {% endfor %}
        </div>
        {% endif %}

        <div>
            <div id="chrom-data-filters">
                <div id="chrom-data-discrete-facets">

                </div>
                <div id="chrom-data-continuous-facets">
                </div>
                <div id="chrom-data-counts">

                </div>
            </div>
            <div id="chrom-data-header" class="text-xl font-bold"></div>
            <div id="chrom-data-legend"></div>
            <div id="chrom-data"></div>
        </div>
    </div>
{% endblock %}

{% block inline_javascript %}
    <script type="module">
        import { a, e, g, rc, t } from "{% static 'search/js/dom.js' %}";
        import { State } from "{% static 'search/js/state.js' %}";
        import { getJson } from "{% static 'search/js/files.js' %}";
        import { Legend } from "{% static 'search/js/obsLegend.js' %}";
        let genome;
        let level1;
        let level2;
        try {
            genome = await getJson("{% get_static_prefix %}search/experiments/{{ experiment.id }}/grch37.json");
            level1 = await getJson("{% get_static_prefix %}search/experiments/{{ experiment.id }}/level1_data.json");
            level2 = [
                await getJson("{% get_static_prefix %}search/experiments/{{experiment.id}}/level2_1.json"),
                await getJson("{% get_static_prefix %}search/experiments/{{experiment.id}}/level2_2.json"),
                await getJson("{% get_static_prefix %}search/experiments/{{experiment.id}}/level2_3.json"),
                await getJson("{% get_static_prefix %}search/experiments/{{experiment.id}}/level2_4.json"),
                await getJson("{% get_static_prefix %}search/experiments/{{experiment.id}}/level2_5.json"),
                await getJson("{% get_static_prefix %}search/experiments/{{experiment.id}}/level2_6.json"),
                await getJson("{% get_static_prefix %}search/experiments/{{experiment.id}}/level2_7.json"),
                await getJson("{% get_static_prefix %}search/experiments/{{experiment.id}}/level2_8.json"),
                await getJson("{% get_static_prefix %}search/experiments/{{experiment.id}}/level2_9.json"),
                await getJson("{% get_static_prefix %}search/experiments/{{experiment.id}}/level2_10.json"),
                await getJson("{% get_static_prefix %}search/experiments/{{experiment.id}}/level2_11.json"),
                await getJson("{% get_static_prefix %}search/experiments/{{experiment.id}}/level2_12.json"),
                await getJson("{% get_static_prefix %}search/experiments/{{experiment.id}}/level2_13.json"),
                await getJson("{% get_static_prefix %}search/experiments/{{experiment.id}}/level2_14.json"),
                await getJson("{% get_static_prefix %}search/experiments/{{experiment.id}}/level2_15.json"),
                await getJson("{% get_static_prefix %}search/experiments/{{experiment.id}}/level2_16.json"),
                await getJson("{% get_static_prefix %}search/experiments/{{experiment.id}}/level2_17.json"),
                await getJson("{% get_static_prefix %}search/experiments/{{experiment.id}}/level2_18.json"),
                await getJson("{% get_static_prefix %}search/experiments/{{experiment.id}}/level2_19.json"),
                await getJson("{% get_static_prefix %}search/experiments/{{experiment.id}}/level2_20.json"),
                await getJson("{% get_static_prefix %}search/experiments/{{experiment.id}}/level2_21.json"),
                await getJson("{% get_static_prefix %}search/experiments/{{experiment.id}}/level2_22.json"),
                await getJson("{% get_static_prefix %}search/experiments/{{experiment.id}}/level2_X.json"),
                await getJson("{% get_static_prefix %}search/experiments/{{experiment.id}}/level2_Y.json"),
                await getJson("{% get_static_prefix %}search/experiments/{{experiment.id}}/level2_MT.json"),
            ]
        } catch (error) {
            // If the files can't be loaded we don't want to even try to show the visualization.
        }

        const ccreColors = d3.interpolateCool;
        const geneColors = d3.interpolateWarm;
        const xInset = 50;
        const yInset = 100;
        const chromHeight = 98;
        const chromSpacing = 10;
        const maxPxChromWidth = 2048;
        const maxChromSize = genome.reduce((a, c) => c.size > a ? c.size : a, 0);
        const viewWidth = maxPxChromWidth + (xInset * 2)
        const viewHeight = (yInset * 2) + (chromHeight + chromSpacing) * genome.length
        const bandColors = {
            acen: '#708090',
            gneg: '#FFFFFF',
            gpos: '#000000',
            gpos100: '#000000',
            gpos25: '#D9D9D9',
            gpos33: '#BFBFBF',
            gpos50: '#999999',
            gpos66: '#7F7F7F',
            gpos75: '#666666',
            gvar: '#E0E0E0',
            stalk: '#708090'
        };
        const svgns = "http://www.w3.org/2000/svg";

        const STATE_ZOOMED = "state-zoomed";
        const STATE_ZOOM_CHROMO_INDEX = "state-zoom-chromo-index";
        const STATE_SCALE = "state-scale";
        const STATE_SCALE_X = "state-scale-x";
        const STATE_SCALE_Y = "state-scale-y";
        const STATE_VIEWBOX = "state-viewbox";
        const STATE_DISCRETE_FACETS = "state-discrete-facets"
        const STATE_CONTINUOUS_FACETS = "state-continuous-facets";
        const STATE_COUNT_FILTER = "state-count-filter";
        const STATE_NON_FILTERED = "state-no-filtered";
        const STATE_DISCRETE_FILTERED = "state-discrete-filtered";
        const STATE_CONTINUOUS_FILTERED = "state-continuous-filtered";
        const STATE_COUNT_FILTERED = "state-count-filtered";
        const STATE_EFFECT_SIZE_INTERVAL = "state-effect-size-interval";
        const STATE_SIGNIFICANCE_INTERVAL = "state-significance-interval";
        const STATE_COUNT_FILTER_INTERVALS = "state-count-filter-intervals";

        let cCRECountInterval = levelCountInterval(level1, "ccre_intervals", "ccres");
        let geneCountInterval = levelCountInterval(level1, "gene_intervals", "genes");
        let state = new State({
            [STATE_ZOOMED]: false,
            [STATE_ZOOM_CHROMO_INDEX]: 0,
            [STATE_SCALE]: 1,
            [STATE_SCALE_X]: 1,
            [STATE_SCALE_Y]: 1,
            [STATE_VIEWBOX]: [0, 0, viewWidth, viewHeight],
            [STATE_DISCRETE_FACETS]: [],
            [STATE_CONTINUOUS_FACETS]: [],
            [STATE_COUNT_FILTER]: [],
            [STATE_NON_FILTERED]: level1,
            [STATE_DISCRETE_FILTERED]: level1,
            [STATE_CONTINUOUS_FILTERED]: level1,
            [STATE_COUNT_FILTERED]: level1,
            [STATE_EFFECT_SIZE_INTERVAL]: [0, 1],
            [STATE_SIGNIFICANCE_INTERVAL]: [0, 1]
            [STATE_COUNT_FILTER_INTERVALS]: {ccre: cCRECountInterval, gene: geneCountInterval}
        });

        class Tooltip {
            constructor() {
                this._count = document.createElementNS(svgns, "text");
                this._count.setAttribute("y", "-32");
                this._range = document.createElementNS(svgns, "text");
                this._range.setAttribute("y", "-20");
                this.node = document.createElementNS(svgns, "g");
                this.node.setAttribute("pointer-events", "none");
                this.node.setAttribute("display", "none");
                this.node.setAttribute("font-family", "sans-serif");
                this.node.setAttribute("font-size", "12");
                this.node.setAttribute("text-anchor", "middle");
                this._rect = document.createElementNS(svgns, "rect");
                this._rect.setAttribute("x", "-85");
                this._rect.setAttribute("width", "170");
                this._rect.setAttribute("y", "-50");
                this._rect.setAttribute("height", "40");
                this._rect.setAttribute("fill", "white");
                this.node.appendChild(this._rect);
                this.node.appendChild(this._count);
                this.node.appendChild(this._range);
            }

            show(chomIdx, d) {
                let scaleX = state.g(STATE_SCALE_X);
                let scaleY = state.g(STATE_SCALE_Y);
                this.node.removeAttribute("display");
                this.node.setAttribute("transform", `translate(${xInset + toPx(d.start) * scaleX}, ${yInset + (chomIdx * (chromHeight + chromSpacing) * scaleY)}) scale(2)`);
                this._count.textContent = `Ct: ${(d.ccres || d.genes).length}`;
                this._range.textContent = `Loc: (${d.start}, ${d.end})`;
            }

            hide() {
                this.node.setAttribute("display", "none");
            }
        }

        const tooltip = new Tooltip();

        rc(g("chrom-data-header"), t("Experiment Coverage"));

        render();

        function renderSVG(currentLevel, cCRECountInterval, geneCountInterval, viewBox, scaleX, scaleY, zoomed) {
            const bucketHeight = 44 * scaleY;
            const cCRECountRange = cCRECountInterval[1] - cCRECountInterval[0];
            const geneCountRange = geneCountInterval[1] - geneCountInterval[0];

            const svg = d3.create("svg")
                .attr("stroke", "black")
                .attr("viewBox", viewBox)
                .style("max-width", `${maxPxChromWidth + 20}px`)
                .style("display", "block")
                .style("margin", "auto");

            let chromGroups = [];
            for (let i = 0; i < genome.length; i++) {
                const frame = svg.append("g");
                chromGroups.push(frame);
                const chrom = frame.append("g");
                chrom.selectAll("path")
                .data(genome[i].bands)
                .join("path")
                    .attr("fill", b => bandColors[b.type])
                    .attr("fill-opacity", 0.3)
                    .attr("stroke", "none")
                    .attr("d", chromosomeBand(i));
                chrom.append("path")
                    .attr("stroke-width", 1)
                    .attr("stroke", "black")
                    .attr("fill", "none")
                    .attr("d", chromosomeOutline(genome[i], i));
            }

            let nameGroup = svg.append("g")
            nameGroup.selectAll("text")
            .data(currentLevel.chromosomes)
            .join("text")
                .attr("x", 10)
                .attr("y", (chromo, i) => yInset  + ((chromHeight / 2) + (chromSpacing + chromHeight) * i) * scaleY)
                .attr("font-size", Math.max(Math.ceil(14 * (scaleY * 0.3)), 14))
                .text(chromo => chromo.chrom)

            for (let i = 0; i < currentLevel.chromosomes.length; i++) {
                const bucketWidth = toPx(currentLevel.chromosomes[i].bucket_size) * scaleX;

                const frame = chromGroups[i];
                const ccreOverlay = frame.append("g");
                ccreOverlay.attr("stroke", "none");

                let ccreRects = ccreOverlay.selectAll("rect")
                .data(currentLevel.chromosomes[i].ccre_intervals.filter(ccre => ccre.ccres.length > 0))
                .join("rect")
                    .attr("fill", ccre => ccreColors((ccre.ccres.length - cCRECountInterval[0]) / cCRECountRange))
                    .attr("x", ccre => xInset + toPx(ccre.start) * scaleX)
                    .attr("y", yInset + (chromSpacing + chromHeight) * i * scaleY)
                    .attr("width", bucketWidth)
                    .attr("height", bucketHeight);

                const geneOverlay = frame.append("g");
                geneOverlay.attr("stroke", "none");
                let geneRects = geneOverlay.selectAll("rect")
                    .data(currentLevel.chromosomes[i].gene_intervals.filter(gene => gene.genes.length > 0))
                    .join("rect")
                    .attr("fill", gene => geneColors((gene.genes.length - geneCountInterval[0]) / geneCountRange))
                    .attr("x", gene => xInset + toPx(gene.start) * scaleX)
                    .attr("y", yInset + (54 + (chromSpacing + chromHeight) * i) * scaleY)
                    .attr("width", bucketWidth)
                    .attr("height", bucketHeight);

                let mouseLeave = () => {
                    ccreRects.attr("stroke", null);
                    ccreRects.attr("stroke-width", null);
                    geneRects.attr("stroke", null);
                    geneRects.attr("stroke-width", null);
                    tooltip.hide();
                }

                let click = (i, start) => {
                    if(zoomed) {
                        state.u(STATE_VIEWBOX, [0, 0, viewWidth, viewHeight]);
                    } else {
                        state.u(STATE_VIEWBOX, [
                            xInset + toPx(start) * 30 - viewHeight / 6,
                            yInset + (chromHeight + chromSpacing) * i * 15 - viewHeight / 6,
                            viewWidth,
                            viewHeight
                        ]);
                        state.u(STATE_ZOOM_CHROMO_INDEX, i);
                    }
                    state.u(STATE_ZOOMED, !zoomed);
                }

                ccreRects.on("mouseenter", (event, rect) => {
                    ccreRects.attr("stroke", node => node.start == rect.start ? "red" : null);
                    ccreRects.attr("stroke-width", node => node.start == rect.start ? 8 : null);

                    let gene_buckets = new Set()
                    for(const ccre of rect.ccres) {
                        for (const gene_bucket of ccre[1]){
                            gene_buckets.add(gene_bucket);
                        }
                    }

                    geneRects.attr("stroke", function(node) {
                        if(gene_buckets.has((node.start - 1) / 2000000)) {
                            return "yellow";
                        }
                        return null
                    });
                    geneRects.attr("stroke-width", function(node) {
                        if(gene_buckets.has((node.start - 1) / 2000000)) {
                            return 8;
                        }
                        return null
                    });
                    rect.end = rect.start + currentLevel.chromosomes[i].bucket_size;
                    tooltip.show(i, rect);
                })
                .on("mouseleave", (event, rect) => {
                    mouseLeave();
                })
                .on("click", (event, rect) => {
                    click(i, rect.start);
                });

                geneRects.on("mouseenter", (event, rect) => {
                    geneRects.attr("stroke", node => node.start == rect.start ? "red" : null);
                    geneRects.attr("stroke-width", node => node.start == rect.start ? 8 : null);

                    let ccre_buckets = new Set()
                    for(const gene of rect.genes) {
                        for (const ccre_bucket of gene[1]){
                            ccre_buckets.add(ccre_bucket);
                        }
                    }

                    ccreRects.attr("stroke", function(node) {
                        if(ccre_buckets.has((node.start - 1) / 2000000)) {
                            return "yellow";
                        }
                        return null
                    });
                    ccreRects.attr("stroke-width", function(node) {
                        if(ccre_buckets.has((node.start - 1) / 2000000)) {
                            return 8;
                        }
                        return null
                    });
                    rect.end = rect.start + currentLevel.chromosomes[i].bucket_size;
                    tooltip.show(i, rect);
                })
                .on("mouseleave", (event, rect) => {
                    mouseLeave();
                })
                .on("click", (event, rect) => {
                    click(i, rect.start);
                });
            }

            svg.append(() => tooltip.node);

            return svg.node();
        }

        function discreteFacetFilter(data, discreteFacetIds) {
            if (discreteFacetIds.length == 0) {
                return data;
            }

            let facets = new Set(discreteFacetIds);
            let filteredData = _.cloneDeep(data);

            for (let cIdx = 0; cIdx < filteredData.chromosomes.length; cIdx++) {
                for (let iIdx = 0; iIdx < filteredData.chromosomes[cIdx].gene_intervals.length; iIdx++) {
                    let newGenes = [];
                    for (let gIdx = 0; gIdx < filteredData.chromosomes[cIdx].gene_intervals[iIdx].genes.length; gIdx++) {
                        let regEffects = filteredData.chromosomes[cIdx].gene_intervals[iIdx].genes[gIdx][0];
                        let newRegEffects = [];
                        for (let rIdx = 0; rIdx < regEffects.length; rIdx += 3) {
                            const facetId = regEffects[rIdx];

                            if (facets.has(facetId)) {
                                newRegEffects.push(facetId, regEffects[rIdx + 1], regEffects[rIdx + 2]);
                            }
                        }

                        if (newRegEffects.length > 0) {
                            newGenes.push([newRegEffects, filteredData.chromosomes[cIdx].gene_intervals[iIdx].genes[gIdx][1]]);
                        }
                    }
                    filteredData.chromosomes[cIdx].gene_intervals[iIdx].genes = newGenes;
                }

                for (let iIdx = 0; iIdx < filteredData.chromosomes[cIdx].ccre_intervals.length; iIdx++) {
                    let newcCREs = [];
                    for (let gIdx = 0; gIdx < filteredData.chromosomes[cIdx].ccre_intervals[iIdx].ccres.length; gIdx++) {
                        let regEffects = filteredData.chromosomes[cIdx].ccre_intervals[iIdx].ccres[gIdx][0];
                        let newRegEffects = [];
                        for (let rIdx = 0; rIdx < regEffects.length; rIdx += 3) {
                            const facetId = regEffects[rIdx];

                            if (facets.has(facetId)) {
                                newRegEffects.push(facetId, regEffects[rIdx + 1], regEffects[rIdx + 2]);
                            }
                        }

                        if (newRegEffects.length > 0) {
                            newcCREs.push([newRegEffects, filteredData.chromosomes[cIdx].ccre_intervals[iIdx].ccres[gIdx][1]]);
                        }
                    }
                    filteredData.chromosomes[cIdx].ccre_intervals[iIdx].ccres = newcCREs;
                }
            }

            return filteredData;
        }


        function chromosomeOutline(d, i) {
            const scale = state.g(STATE_SCALE);
            const scaleX = state.g(STATE_SCALE_X);
            const scaleY = state.g(STATE_SCALE_Y);
            const width = toPx(d.size) * scaleX;
            const top = yInset + (chromSpacing + chromHeight) * i * scaleY;
            const bottom = top + chromHeight * scaleY;
            const outlinePath = ["M", xInset, ",", top];
            outlinePath.push(
                "C", xInset - (12 * scale) ,",", top, " ",
                xInset - (12 * scale) , ",", bottom, " ",
                xInset, ",", bottom,
            );
            outlinePath.push("M", xInset + width ,",", top);
            outlinePath.push(
                "C", xInset + width + (12 * scale) ,",", top, " ",
                xInset + width + (12 * scale) , ",", bottom, " ",
                xInset + width, ",", bottom,
            );

            for(const band of d.bands) {
                let bandStart = band.start < band.end ? band.start : band.end;
                let bandEnd = band.start > band.end ? band.start : band.end;
                let bandPxStart = toPx(bandStart) * scaleX;
                let bandPxEnd = toPx(bandEnd) * scaleX;
                let bandPxWidth = bandPxEnd - bandPxStart;

                if(band.type == "acen") {
                    if(band.id.startsWith("p")) {
                        outlinePath.push("M", xInset + bandPxStart ,",", top);
                        outlinePath.push("l", bandPxWidth, ",", chromHeight / 2 * scaleY);
                        outlinePath.push("l", -bandPxWidth, ",", chromHeight / 2 * scaleY);
                    } else {
                        outlinePath.push("M", xInset + bandPxEnd ,",", top);
                        outlinePath.push("l", -bandPxWidth, ",", chromHeight / 2 * scaleY);
                        outlinePath.push("l", bandPxWidth, ",", chromHeight / 2 * scaleY);
                    }
                } else {
                    outlinePath.push("M", xInset + bandPxStart ,",", top);
                    outlinePath.push("l", bandPxWidth, ",", 0);
                    outlinePath.push("M", xInset + bandPxStart ,",", bottom);
                    outlinePath.push("l", bandPxWidth, ",", 0);
                }
            }

            return outlinePath.join("");
        }

        function chromosomeBand(chromIndex) {
            return function(band) {
                const scaleX = state.g(STATE_SCALE_X);
                const scaleY = state.g(STATE_SCALE_Y);
                const top = yInset + (chromSpacing + chromHeight) * chromIndex * scaleY;
                const bottom = top + chromHeight * scaleY;
                let bandStart = band.start < band.end ? band.start : band.end;
                let bandPxStart = toPx(bandStart) * scaleX;
                let bandEnd = band.start > band.end ? band.start : band.end;
                let bandPxEnd = toPx(bandEnd) * scaleX;
                let bandSize = bandEnd - bandStart;
                let bandPxWidth = bandPxEnd - bandPxStart;
                let outlinePath = ["M", xInset + bandPxStart, ",", top];
                if(band.type == "acen") {
                    if(band.id.startsWith("p")) {
                        outlinePath.push("M", xInset + bandPxStart ,",", top);
                        outlinePath.push("l", bandPxWidth, ",", chromHeight / 2 * scaleY);
                        outlinePath.push("l", -bandPxWidth, ",", chromHeight / 2 * scaleY);
                    } else {
                        outlinePath.push("M", xInset + bandPxEnd ,",", top);
                        outlinePath.push("l", -bandPxWidth, ",", chromHeight / 2 * scaleY);
                        outlinePath.push("l", bandPxWidth, ",", chromHeight / 2 * scaleY);
                    }
                } else {
                    outlinePath.push("l", 0, ",", chromHeight * scaleY);
                    outlinePath.push("l", bandPxWidth, ",", 0);
                    outlinePath.push("l", 0, ",", -chromHeight * scaleY);
                    outlinePath.push("l", -bandPxWidth, ",", 0);
                }

                return outlinePath.join("");
            }
        }

        function toPx(size) {
            return maxPxChromWidth * (size / maxChromSize);
        }

        function levelCountInterval(data, interval, item, chromoIndex) {
            let chroms = data.chromosomes;
            if (chromoIndex) {
                chroms = [chroms[chromoIndex]];
            }
            let max = Number.NEGATIVE_INFINITY;
            let min = Number.POSITIVE_INFINITY;
            for (const chrom of chroms) {
                const count = chrom[interval].map(d => d[item].length);
                max = Math.max(max, Math.max(...chrom[interval].map(d => d[item].length)));
                min = Math.min(min, Math.min(...chrom[interval].map(d => d[item].length)));
            }

            return [min, max];
        }

        function regEffectDataInterval(data, dataOffset, chromoIndex) {
            let chroms = data.chromosomes;
            if (chromoIndex) {
                chroms = [chroms[chromoIndex]];
            }
            let max = Number.NEGATIVE_INFINITY;
            let min = Number.POSITIVE_INFINITY;
            for (const chrom of chroms) {
                for (const geneInterval of chrom.gene_intervals) {
                    for (const gene of geneInterval.genes) {
                        for (let i = dataOffset; i < gene[0].length; i += 3) {
                            max = Math.max(max, gene[0][i]);
                            min = Math.min(min, gene[0][i]);
                        }
                    }
                }
                for (const ccreInterval of chrom.ccre_intervals) {
                    for (const ccre of ccreInterval.ccres) {
                        for (let i = dataOffset; i < ccre[0].length; i += 3) {
                            max = Math.max(max, ccre[0][i]);
                            min = Math.min(min, ccre[0][i]);
                        }
                    }
                }
            }

            return [min, max];
        }

        function discreteFilterControls(facets) {
            return facets
            .filter(f => f.type == "FacetType.DISCRETE")
            .map(facet => {
                return e("fieldset", {name: "facetfield"}, [
                    e("legend", facet.name),
                    e("div", {class: "flex flex-row flex-wrap gap-1"},
                    Object.entries(facet.values).map(entry => {
                        return e("div", [
                            e("input", {type:"checkbox", id:entry[0], name:facet.name}, []),
                            e("label", {for:entry[0]}, entry[1])
                        ])
                    })
                    )
                ])
            });
        }

        discreteFilterControls(level1.facets).forEach(element => {
            a(g("chrom-data-discrete-facets"), element)
        });

        const discreteFacets = g("chrom-data-discrete-facets");
        const facetCheckboxes = discreteFacets.querySelectorAll("input[type=checkbox]");

        facetCheckboxes.forEach(checkbox => {
            checkbox.addEventListener("change", _ => {
                let checkedFacets = Array.from(facetCheckboxes) // Convert checkboxes to an array to use filter and map.
                                    .filter(i => i.checked) // Use Array.filter to remove unchecked checkboxes.
                                    .map(i => Number(i.id))
                state.updateSharedState(STATE_DISCRETE_FACETS, checkedFacets);
            });
        });

        function continuousFilterControls(facets) {
            const contFacets = facets.filter(f => f.type == "FacetType.CONTINUOUS");
            let sliderNodes = contFacets.map(_ => e("div", {name: "facetslider"}, []));
            let filterNodes = [];

            for (let i = 0; i < contFacets.length; i++) {
                let facet = contFacets[i];
                let sliderNode = sliderNodes[i];

                noUiSlider.create(sliderNode, {
                    start: [facet.range[0], facet.range[1]],
                    connect: true,
                    range: {
                        'min': facet.range[0],
                        'max': facet.range[1]
                    },
                    pips: {
                        mode: 'range',
                        density: 5
                    }
                });

                sliderNode.noUiSlider.on("start", function(values, handle) {
                    sliderNode.noUiSlider.updateOptions({tooltips: [true, true]});
                })

                sliderNode.noUiSlider.on("end", function(values, handle) {
                    sliderNode.noUiSlider.updateOptions({tooltips: [false, false]});
                })

                filterNodes.push(e("div", {class: "h-24"}, [
                    e("div", facet.name),
                    sliderNode
                ]))
            }


            return filterNodes;
        }

        continuousFilterControls(level1.facets).forEach(element => {
            a(g("chrom-data-continuous-facets"), element)
        });

        function countFilterControls() {
            let sliderNodes = [e("div", {name: "facetslider"}, []), e("div", {name: "facetslider"}, [])];
            let filterNodes = [];
            let intervals = state.g(STATE_COUNT_FILTER_INTERVALS);

            let range = intervals.ccre;

            for (let i = 0; i < 2; i++) {
                let sliderNode = sliderNodes[i];

                let range;
                let name;

                if (i == 0) {
                    range = intervals.ccre;
                    name = "cCRE Count";
                } else if (i == 1) {
                    range = intervals.gene;
                    name = "Gene count";
                } else {
                    continue;
                }

                noUiSlider.create(sliderNode, {
                    start: [range[0], range[1]],
                    step: 1,
                    connect: true,
                    range: {
                        'min': range[0],
                        'max': range[1]
                    },
                    pips: {
                        mode: 'range',
                        density: 5,

                    }
                });

                sliderNode.noUiSlider.on("start", function(values, handle) {
                    sliderNode.noUiSlider.updateOptions({tooltips: [true, true]});
                })

                sliderNode.noUiSlider.on("end", function(values, handle) {
                    sliderNode.noUiSlider.updateOptions({tooltips: [false, false]});
                })

                sliderNode.noUiSlider.on("update", function(values, handle) {
                    //sliderNode.noUiSlider.updateOptions({tooltips: [false, false]});
                })

                filterNodes.push(e("div", {class: "h-24"}, [
                    e("div", name),
                    sliderNode
                ]))
            }

            return filterNodes;
        }

        countFilterControls().forEach(element => {
            a(g("chrom-data-counts"), element)
        });

        function render() {
            const scale = state.g(STATE_SCALE);
            const scaleX = state.g(STATE_SCALE_X);
            const scaleY = state.g(STATE_SCALE_Y);
            const viewBox = state.g(STATE_VIEWBOX);
            const zoomed = state.g(STATE_ZOOMED);
            const zoomChromoIndex = state.g(STATE_ZOOM_CHROMO_INDEX);
            let currentLevel = state.g(STATE_DISCRETE_FILTERED);
            let countIntervals = state.g(STATE_COUNT_FILTER_INTERVALS);
            let cCRECountInterval = countIntervals.ccre;
            let geneCountInterval = countIntervals.gene;

            rc(g("chrom-data"), renderSVG(currentLevel, cCRECountInterval, geneCountInterval, viewBox, scaleX, scaleY, zoomed));
            rc(g("chrom-data-legend"), Legend(d3.scaleSequential(cCRECountInterval, ccreColors), {
                title: "cCRE Count"
            }));
            a(g("chrom-data-legend"), Legend(d3.scaleSequential(geneCountInterval, geneColors), {
                title: "Gene Count"
            }));
        }

        state.ac(STATE_ZOOMED, (s, key) => {
            const zoomed = s[key];
            const scale = zoomed ? 15 : 1;
            const scaleX = zoomed ? 30 : 1;
            const scaleY = zoomed ? 15 : 1;
            state.u(STATE_SCALE, scale);
            state.u(STATE_SCALE_X, scaleX);
            state.u(STATE_SCALE_Y, scaleY);

            if (zoomed) {
                let zoomChromoIndex = state.g(STATE_ZOOM_CHROMO_INDEX);
                let zoomedLevel = _.cloneDeep(level1);
                zoomedLevel.chromosomes[zoomChromoIndex] = level2[zoomChromoIndex].chromosomes[0];
                state.u(STATE_NON_FILTERED, zoomedLevel);
            } else {
                state.u(STATE_ZOOM_CHROMO_INDEX, undefined);
                state.u(STATE_NON_FILTERED, level1);
            }
        });

        state.ac([STATE_NON_FILTERED, STATE_DISCRETE_FACETS], (s, key) => {
            const currentLevel = state.g(STATE_NON_FILTERED);
            let discreteFilteredLevel = discreteFacetFilter(currentLevel, state.g(STATE_DISCRETE_FACETS))
            let chromoIndex = state.g(STATE_ZOOM_CHROMO_INDEX);
            state.u(STATE_DISCRETE_FILTERED, discreteFilteredLevel)
            state.u(STATE_EFFECT_SIZE_INTERVAL, regEffectDataInterval(discreteFilteredLevel, 1, chromoIndex));
            state.u(STATE_SIGNIFICANCE_INTERVAL, regEffectDataInterval(discreteFilteredLevel, 2, chromoIndex));
            let cCRECountInterval = levelCountInterval(discreteFilteredLevel, "ccre_intervals", "ccres", chromoIndex);
            let geneCountInterval = levelCountInterval(discreteFilteredLevel, "gene_intervals", "genes", chromoIndex);
            state.u(STATE_CCRE_COUNT_INTERVAL, cCRECountInterval);
            state.u(STATE_GENE_COUNT_INTERVAL, geneCountInterval);
            render();
        });






    </script>
{% endblock %}
