{% extends "base.html" %}
{% load static i18n %}

{% block css %}
{{ block.super }}
<link href="{% static 'css/nouislider.min.css' %}" rel="stylesheet">
<style>
    .noUi-horizontal {
        height: 10px;
    }

    .noUi-horizontal .noUi-handle {
        width: 20px;
        height: 20px;
    }

    .noUi-handle {
        border-radius: 10px;
    }

    .noUi-handle:before, .noUi-handle:after {
        display: none;
    }

    .noUi-connect {
        background: rgba(1, 33, 105, 1);
    }

    .noUi-pips-horizontal {
        transform: translate(6px);
    }
</style>
{% endblock %}

{% block javascript %}
{{ block.super }}
<script type="text/javascript" src="{% static 'js/lodash.min.js' %}"></script>
<script type="text/javascript" src="{% static 'js/nouislider.min.js' %}"></script>
<script type="text/javascript" src="{% static 'search/js/vizUtils.js' %}"></script>
<script type="text/javascript" src="https://d3js.org/d3.v7.min.js"></script>
{% endblock %}

{% block title %}Experiment{% endblock %}
{% block content %}
    <div class="max-w-5xl">
        <div class="text-2xl font-bold">{{ experiment.accession_id }}: {{ experiment.name }}</div>
        <table class="data-table">
            <tr><th>Description</th><td>{{ experiment.description }}</td></tr>
            <tr><th>Assay</th><td>{{ experiment.experiment_type }}</td></tr>
            <tr><th>Cell Lines</th><td>{{ experiment.cell_lines|join:", " }}</td></tr>
            <tr><th>Tissue Types</th><td>{{ experiment.tissue_types|join:", " }}</td></tr>
            <tr><th>Assemblies</th><td>{{ experiment.assemblies|join:", " }}</td></tr>
        </table>

        {% if experiment.data_files.all|length > 0 %}
        <div>
            <div class="text-xl font-bold">Data Files</div>
            {% for file in experiment.data_files.all %}
            <table class="data-table">
                <tr><th>File Name</th><td>{{ file.filename }}</td></tr>
                <tr><th>Description</th><td>{{ file.description }}</td></tr>
                <tr><th>Cell Lines</th><td>{{ file.cell_lines.all|join:", " }}</td></tr>
                <tr><th>Tissue Types</th><td>{{ file.tissue_types.all|join:", " }}</td></tr>
                <tr><th>Assembly</th><td>{{ file.ref_genome }}.{{ file.ref_genome_patch|default:"0" }}</td></tr>
            </table>
            {% endfor %}
        </div>
        {% endif %}

        {% if experiment.other_files.all|length > 0 %}
        <div>
            <div class="text-xl font-bold">Other Files</div>
            {% for file in experiment.other_files.all %}
            <table class="data-table">
                <tr><th>File Name</th><td>{{ file.filename }}</td></tr>
                <tr><th>Description</th><td>{{ file.description }}</td></tr>
                <tr><th>Location</th><td><a href="{{ file.url }}">{{ file.url }}</a></td></tr>
            </table>
            {% endfor %}
        </div>
        {% endif %}

        <div id="experiment-coverage" class="mt-4">
            <div id="chrom-data-header" class="text-xl font-bold"></div>
            <div class="flex flex-row">
                <div id="chrom-data-filters" class="basis-1/3">
                    <div id="chrom-data-discrete-facets"></div>
                    <div id="chrom-data-continuous-facets"></div>
                    <div id="chrom-data-counts"></div>
                </div>
                <div class="basis-2/3">
                    <div id="chrom-data-legend"></div>
                    <div id="chrom-data"></div>
                </div>
            </div>
        </div>
    </div>
{% endblock %}

{% block inline_javascript %}
    <script type="module">
        import { a, cc, e, g, rc, t } from "{% static 'search/js/dom.js' %}";
        import { State } from "{% static 'search/js/state.js' %}";
        import { getJson, postJson } from "{% static 'search/js/files.js' %}";
        import { Legend } from "{% static 'search/js/obsLegend.js' %}";

        let genome;
        let coverageData;
        let facets;
        try {
            let manifest = await getJson("{% get_static_prefix %}search/experiments/{{ experiment.accession_id }}/coverage_manifest.json");
            genome = await getJson(`{% get_static_prefix %}search/experiments/{{ experiment.accession_id }}/${manifest.genome}`);
            coverageData = manifest["chromosomes"];
            facets = manifest["facets"];
        } catch (error) {
            // If the files can't be loaded we don't want to even try to show the visualization.
        }

        const sourceColors = d3.interpolateCool;
        const targetColors = d3.interpolateWarm;
        const xInset = 60;
        const yInset = 100;
        const chromHeight = 98;
        const chromSpacing = 10;
        const maxPxChromWidth = 2048;
        const maxChromSize = genome.reduce((a, c) => c.size > a ? c.size : a, 0);
        const viewWidth = maxPxChromWidth + (xInset * 2)
        const viewHeight = (yInset * 2) + (chromHeight + chromSpacing) * genome.length
        const bandColors = {
            acen: '#708090',
            gneg: '#FFFFFF',
            gpos: '#000000',
            gpos100: '#000000',
            gpos25: '#D9D9D9',
            gpos33: '#BFBFBF',
            gpos50: '#999999',
            gpos66: '#7F7F7F',
            gpos75: '#666666',
            gvar: '#E0E0E0',
            stalk: '#708090'
        };
        const svgns = "http://www.w3.org/2000/svg";

        const STATE_ZOOMED = "state-zoomed";
        const STATE_ZOOM_CHROMO_INDEX = "state-zoom-chromo-index";
        const STATE_SCALE = "state-scale";
        const STATE_SCALE_X = "state-scale-x";
        const STATE_SCALE_Y = "state-scale-y";
        const STATE_VIEWBOX = "state-viewbox";
        const STATE_DISCRETE_FACET_VALUES = "state-discrete-facets"
        const STATE_CONTINUOUS_FACET_VALUES = "state-continuous-facets";
        const STATE_COUNT_FILTER_VALUES = "state-count-filter";
        const STATE_COVERAGE_DATA = "state-coverage-data";
        const STATE_ALL_FILTERED = "state-all-filtered";
        const STATE_CONTINUOUS_FILTER_INTERVALS = "state-continuous-filter-intervals";
        const STATE_COUNT_FILTER_INTERVALS = "state-count-filter-intervals";

        let sourceCountInterval = levelCountInterval(coverageData, "source_intervals");
        let targetCountInterval = levelCountInterval(coverageData, "target_intervals");
        let effectSizeInterval = facets.filter(f => f.name === "Effect Size")[0].range
        let sigInterval = facets.filter(f => f.name === "Significance")[0].range
        let state = new State({
            [STATE_ZOOMED]: false,
            [STATE_ZOOM_CHROMO_INDEX]: undefined,
            [STATE_SCALE]: 1,
            [STATE_SCALE_X]: 1,
            [STATE_SCALE_Y]: 1,
            [STATE_VIEWBOX]: [0, 0, viewWidth, viewHeight],
            [STATE_DISCRETE_FACET_VALUES]: [],
            [STATE_CONTINUOUS_FACET_VALUES]: [effectSizeInterval, sigInterval],
            [STATE_COUNT_FILTER_VALUES]: [sourceCountInterval, targetCountInterval],
            [STATE_COVERAGE_DATA]: coverageData,
            [STATE_ALL_FILTERED]: coverageData,
            [STATE_CONTINUOUS_FILTER_INTERVALS]: {effectSize: effectSizeInterval, significance: sigInterval},
            [STATE_COUNT_FILTER_INTERVALS]: {source: sourceCountInterval, target: targetCountInterval}
        });

        let countFacetWorker;
        if (window.Worker) {
            countFacetWorker = new Worker("{% static 'search/js/countFacetFilterWorker.js' %}")
            countFacetWorker.onmessage = (cf) => {
                state.u(STATE_ALL_FILTERED, cf.data);
            }
        }

        class Tooltip {
            constructor() {
                this._count = document.createElementNS(svgns, "text");
                this._count.setAttribute("y", "-32");
                this._range = document.createElementNS(svgns, "text");
                this._range.setAttribute("y", "-20");
                this.node = document.createElementNS(svgns, "g");
                this.node.setAttribute("pointer-events", "none");
                this.node.setAttribute("display", "none");
                this.node.setAttribute("font-family", "sans-serif");
                this.node.setAttribute("font-size", "12");
                this.node.setAttribute("text-anchor", "middle");
                this._rect = document.createElementNS(svgns, "rect");
                this._rect.setAttribute("x", "-85");
                this._rect.setAttribute("width", "170");
                this._rect.setAttribute("y", "-50");
                this._rect.setAttribute("height", "40");
                this._rect.setAttribute("fill", "white");
                this.node.appendChild(this._rect);
                this.node.appendChild(this._count);
                this.node.appendChild(this._range);
            }

            show(chomIdx, d) {
                let scaleX = state.g(STATE_SCALE_X);
                let scaleY = state.g(STATE_SCALE_Y);
                this.node.removeAttribute("display");
                this.node.setAttribute("transform", `translate(${xInset + toPx(d.start) * scaleX}, ${yInset + (chomIdx * (chromHeight + chromSpacing) * scaleY)}) scale(2)`);
                this._count.textContent = `Ct: ${d.count}`;
                this._range.textContent = `Loc: (${d.start}, ${d.end})`;
            }

            hide() {
                this.node.setAttribute("display", "none");
            }
        }

        const tooltip = new Tooltip();

        rc(g("chrom-data-header"), t("Experiment Coverage"));

        render();

        function renderSVG(coverageData, sourceCountInterval, targetCountInterval, viewBox, scaleX, scaleY, zoomed) {
            const bucketHeight = 44 * scaleY;
            const sourceCountRange = sourceCountInterval[1] - sourceCountInterval[0];
            const targetCountRange = targetCountInterval[1] - targetCountInterval[0];

            const svg = d3.create("svg")
                .attr("stroke", "black")
                .attr("viewBox", viewBox)
                .style("max-width", `${maxPxChromWidth + 20}px`)
                .style("display", "block")
                .style("margin", "auto");

            let chromGroups = [];
            for (let i = 0; i < genome.length; i++) {
                const frame = svg.append("g");
                chromGroups.push(frame);
                const chrom = frame.append("g");
                chrom.selectAll("path")
                .data(genome[i].bands)
                .join("path")
                    .attr("fill", b => bandColors[b.type])
                    .attr("fill-opacity", 0.3)
                    .attr("stroke", "none")
                    .attr("d", chromosomeBand(i));
                chrom.append("path")
                    .attr("stroke-width", 1)
                    .attr("stroke", "black")
                    .attr("fill", "none")
                    .attr("d", chromosomeOutline(genome[i], i));
            }

            let nameGroup = svg.append("g")
            nameGroup.selectAll("text")
            .data(coverageData)
            .join("text")
                .attr("x", 0)
                .attr("y", (chromo, i) => yInset  + ((chromHeight / 2) + (chromSpacing + chromHeight) * i) * scaleY)
                .attr("font-size", Math.max(Math.ceil(14 * (scaleY * 0.3)), 32))
                .text(chromo => chromo.chrom)

            let allSourceRects = {};
            let allTargetRects = {};

            for (let i = 0; i < coverageData.length; i++) {
                const bucketSize = coverageData[i].bucket_size;
                const bucketWidth = toPx(bucketSize) * scaleX;

                const frame = chromGroups[i];
                const sourceOverlay = frame.append("g");
                sourceOverlay.attr("stroke", "none");

                let sourceRects = sourceOverlay.selectAll("rect")
                .data(coverageData[i].source_intervals)
                .join("rect")
                    .attr("fill", source => sourceColors((source.count - sourceCountInterval[0]) / sourceCountRange))
                    .attr("x", source => xInset + toPx(source.start) * scaleX)
                    .attr("y", yInset + (chromSpacing + chromHeight) * i * scaleY)
                    .attr("width", bucketWidth)
                    .attr("height", bucketHeight);

                allSourceRects[i] = sourceRects;

                const targetOverlay = frame.append("g");
                targetOverlay.attr("stroke", "none");
                let targetRects = targetOverlay.selectAll("rect")
                    .data(coverageData[i].target_intervals)
                    .join("rect")
                    .attr("fill", target => targetColors((target.count - targetCountInterval[0]) / targetCountRange))
                    .attr("x", target => xInset + toPx(target.start) * scaleX)
                    .attr("y", yInset + (54 + (chromSpacing + chromHeight) * i) * scaleY)
                    .attr("width", bucketWidth)
                    .attr("height", bucketHeight);

                allTargetRects[i] = targetRects;

                let mouseLeave = () => {
                    for (const k of Object.keys(allSourceRects)) {
                        allSourceRects[k].attr("stroke", null);
                        allSourceRects[k].attr("stroke-width", null);
                    }
                    for (const k of Object.keys(allTargetRects)) {
                        allTargetRects[k].attr("stroke", null);
                        allTargetRects[k].attr("stroke-width", null);
                    }
                    tooltip.hide();
                }

                let click = (i, start) => {
                    if(zoomed) {
                        state.u(STATE_VIEWBOX, [0, 0, viewWidth, viewHeight]);
                    } else {
                        state.u(STATE_VIEWBOX, [
                            xInset + toPx(start) * 30 - viewHeight / 6,
                            yInset + (chromHeight + chromSpacing) * i * 15 - viewHeight / 6,
                            viewWidth,
                            viewHeight
                        ]);
                        state.u(STATE_ZOOM_CHROMO_INDEX, i);
                    }
                    state.u(STATE_ZOOMED, !zoomed);
                }

                sourceRects.on("mouseenter", (event, rect) => {
                    sourceRects.attr("stroke", node => node.start == rect.start ? "red" : null);
                    sourceRects.attr("stroke-width", node => node.start == rect.start ? 8 : null);

                    let target_buckets = new Array(coverageData.length);
                    for (let i = 0; i < target_buckets.length; i++) {
                        target_buckets[i] = new Set()
                    }

                    for(let i = 0; i < rect.assoc_targets.length; i += 2) {
                        target_buckets[rect.assoc_targets[i]].add(rect.assoc_targets[i+1]);
                    }

                    for (let i = 0; i < target_buckets.length; i++) {
                        let target_bucket = target_buckets[i];
                        for (let j = 0; j < target_bucket.size; j += 2) {
                            let targetRects = allTargetRects[i];
                            targetRects.attr("stroke", function(node) {
                                if(target_bucket.has((node.start - 1) / bucketSize)) {
                                    return "yellow";
                                }
                                return null
                            });
                            targetRects.attr("stroke-width", function(node) {
                                if(target_bucket.has((node.start - 1) / bucketSize)) {
                                    return 8;
                                }
                                return null
                            });
                        }
                    }

                    rect.end = rect.start + bucketSize;
                    tooltip.show(i, rect);
                })
                .on("mouseleave", (event, rect) => {
                    mouseLeave();
                })
                .on("click", (event, rect) => {
                    click(i, rect.start);
                });

                targetRects.on("mouseenter", (event, rect) => {
                    targetRects.attr("stroke", node => node.start == rect.start ? "red" : null);
                    targetRects.attr("stroke-width", node => node.start == rect.start ? 8 : null);

                    let source_buckets = new Array(coverageData.length)
                    for (let i = 0; i < source_buckets.length; i++) {
                        source_buckets[i] = new Set()
                    }

                    for(let i = 0; i < rect.assoc_sources.length; i += 2) {
                        source_buckets[rect.assoc_sources[i]].add(rect.assoc_sources[i+1]);
                    }

                    for (let i = 0; i < source_buckets.length; i++) {
                        let source_bucket = source_buckets[i];
                        for (let j = 0; j < source_bucket.size; j += 2) {
                            let sourceRects = allSourceRects[i];
                            sourceRects.attr("stroke", function(node) {
                                if(source_bucket.has((node.start - 1) / bucketSize)) {
                                    return "yellow";
                                }
                                return null
                            });
                            sourceRects.attr("stroke-width", function(node) {
                                if(source_bucket.has((node.start - 1) / bucketSize)) {
                                    return 8;
                                }
                                return null
                            });
                        }
                    }

                    rect.end = rect.start + bucketSize;
                    tooltip.show(i, rect);
                })
                .on("mouseleave", (event, rect) => {
                    mouseLeave();
                })
                .on("click", (event, rect) => {
                    click(i, rect.start);
                });
            }

            svg.append(() => tooltip.node);

            return svg.node();
        }

        function chromosomeOutline(d, i) {
            const scale = state.g(STATE_SCALE);
            const scaleX = state.g(STATE_SCALE_X);
            const scaleY = state.g(STATE_SCALE_Y);
            const width = toPx(d.size) * scaleX;
            const top = yInset + (chromSpacing + chromHeight) * i * scaleY;
            const bottom = top + chromHeight * scaleY;
            const outlinePath = ["M", xInset, ",", top];
            outlinePath.push(
                "C", xInset - (12 * scale) ,",", top, " ",
                xInset - (12 * scale) , ",", bottom, " ",
                xInset, ",", bottom,
            );
            outlinePath.push("M", xInset + width ,",", top);
            outlinePath.push(
                "C", xInset + width + (12 * scale) ,",", top, " ",
                xInset + width + (12 * scale) , ",", bottom, " ",
                xInset + width, ",", bottom,
            );

            for(const band of d.bands) {
                let bandStart = band.start < band.end ? band.start : band.end;
                let bandEnd = band.start > band.end ? band.start : band.end;
                let bandPxStart = toPx(bandStart) * scaleX;
                let bandPxEnd = toPx(bandEnd) * scaleX;
                let bandPxWidth = bandPxEnd - bandPxStart;

                if(band.type == "acen") {
                    if(band.id.startsWith("p")) {
                        outlinePath.push("M", xInset + bandPxStart ,",", top);
                        outlinePath.push("l", bandPxWidth, ",", chromHeight / 2 * scaleY);
                        outlinePath.push("l", -bandPxWidth, ",", chromHeight / 2 * scaleY);
                    } else {
                        outlinePath.push("M", xInset + bandPxEnd ,",", top);
                        outlinePath.push("l", -bandPxWidth, ",", chromHeight / 2 * scaleY);
                        outlinePath.push("l", bandPxWidth, ",", chromHeight / 2 * scaleY);
                    }
                } else {
                    outlinePath.push("M", xInset + bandPxStart ,",", top);
                    outlinePath.push("l", bandPxWidth, ",", 0);
                    outlinePath.push("M", xInset + bandPxStart ,",", bottom);
                    outlinePath.push("l", bandPxWidth, ",", 0);
                }
            }

            return outlinePath.join("");
        }

        function chromosomeBand(chromIndex) {
            return function(band) {
                const scaleX = state.g(STATE_SCALE_X);
                const scaleY = state.g(STATE_SCALE_Y);
                const top = yInset + (chromSpacing + chromHeight) * chromIndex * scaleY;
                const bottom = top + chromHeight * scaleY;
                let bandStart = band.start < band.end ? band.start : band.end;
                let bandPxStart = toPx(bandStart) * scaleX;
                let bandEnd = band.start > band.end ? band.start : band.end;
                let bandPxEnd = toPx(bandEnd) * scaleX;
                let bandSize = bandEnd - bandStart;
                let bandPxWidth = bandPxEnd - bandPxStart;
                let outlinePath = ["M", xInset + bandPxStart, ",", top];
                if(band.type == "acen") {
                    if(band.id.startsWith("p")) {
                        outlinePath.push("M", xInset + bandPxStart ,",", top);
                        outlinePath.push("l", bandPxWidth, ",", chromHeight / 2 * scaleY);
                        outlinePath.push("l", -bandPxWidth, ",", chromHeight / 2 * scaleY);
                    } else {
                        outlinePath.push("M", xInset + bandPxEnd ,",", top);
                        outlinePath.push("l", -bandPxWidth, ",", chromHeight / 2 * scaleY);
                        outlinePath.push("l", bandPxWidth, ",", chromHeight / 2 * scaleY);
                    }
                } else {
                    outlinePath.push("l", 0, ",", chromHeight * scaleY);
                    outlinePath.push("l", bandPxWidth, ",", 0);
                    outlinePath.push("l", 0, ",", -chromHeight * scaleY);
                    outlinePath.push("l", -bandPxWidth, ",", 0);
                }

                return outlinePath.join("");
            }
        }

        function toPx(size) {
            return maxPxChromWidth * (size / maxChromSize);
        }

        function levelCountInterval(chroms, interval, chromoIndex) {
            if (chromoIndex) {
                chroms = [chroms[chromoIndex]];
            }
            let max = Number.NEGATIVE_INFINITY;
            let min = Number.POSITIVE_INFINITY;
            for (const chrom of chroms) {
                const count = chrom[interval].map(d => d.count);
                max = Math.max(max, Math.max(...count));
                min = Math.min(min, Math.min(...count));
            }

            if (max == Number.NEGATIVE_INFINITY || min == Number.POSITIVE_INFINITY) {
                return [0, 0];
            }

            return [min, max];
        }

        function discreteFilterControls(facets) {
            return facets
            .filter(f => f.type == "FacetType.DISCRETE")
            .map(facet => {
                return e("fieldset", {name: "facetfield", class:"my-4"}, [
                    e("legend", {class:"font-bold"}, facet.name),
                    e("div", {class: "flex flex-row flex-wrap gap-1"},
                    Object.entries(facet.values).map(entry => {
                        return e("div", {class:"ml-1"}, [
                            e("input", {type:"checkbox", id:entry[0], name:facet.name}, []),
                            e("label", {for:entry[0]}, entry[1])
                        ])
                    })
                    )
                ])
            });
        }

        discreteFilterControls(facets).forEach(element => {
            a(g("chrom-data-discrete-facets"), element)
        });

        const discreteFacets = g("chrom-data-discrete-facets");
        const facetCheckboxes = discreteFacets.querySelectorAll("input[type=checkbox]");

        facetCheckboxes.forEach(checkbox => {
            checkbox.addEventListener("change", _ => {
                let checkedFacets = Array.from(facetCheckboxes) // Convert checkboxes to an array to use filter and map.
                                    .filter(i => i.checked) // Use Array.filter to remove unchecked checkboxes.
                                    .map(i => Number(i.id))
                state.updateSharedState(STATE_DISCRETE_FACET_VALUES, checkedFacets);
            });
        });

        function continuousFilterControls() {
            const contFacets = facets.filter(f => f.type == "FacetType.CONTINUOUS");
            let sliderNodes = [e("div", {name: "facetslider"}, []), e("div", {name: "facetslider"}, [])];
            let filterNodes = [];
            let intervals = state.g(STATE_CONTINUOUS_FILTER_INTERVALS);

            for (let i = 0; i < contFacets.length; i++) {
                let facet = contFacets[i];
                let sliderNode = sliderNodes[i];

                let range;

                if (facet.name === "Effect Size") {
                    range = intervals.effectSize;
                } else if (facet.name === "Significance") {
                    range = intervals.significance;
                } else {
                    continue;
                }

                noUiSlider.create(sliderNode, {
                    start: [range[0], range[1]],
                    format: {
                        to: n => n.toPrecision(3),
                        from: s => Number.parseFloat(s)
                    },
                    connect: true,
                    range: {
                        'min': range[0],
                        'max': range[1]
                    },
                    pips: {
                        mode: 'range',
                        density: 5,
                        format: {
                            to: n => n.toPrecision(3),
                            from: s => Number.parseFloat(s)
                        }
                    }
                });

                sliderNode.noUiSlider.on("start", function(values, handle) {
                    sliderNode.noUiSlider.updateOptions({tooltips: [true, true]});
                })

                sliderNode.noUiSlider.on("end", function(values, handle) {
                    sliderNode.noUiSlider.updateOptions({tooltips: [false, false]});
                })

                filterNodes.push(e("div", {class: "h-24 w-72"}, [
                    e("div", facet.name),
                    sliderNode
                ]))
            }

            sliderNodes.forEach(sliderNode => {
                sliderNode.noUiSlider.on("slide", function(values, handle) {
                    state.u(STATE_CONTINUOUS_FACET_VALUES, sliderNodes.map(n => n.noUiSlider.get(true)));
                })
            })

            return filterNodes;
        }

        continuousFilterControls().forEach(element => {
            a(g("chrom-data-continuous-facets"), element)
        });

        function countFilterControls() {
            let sliderNodes = [e("div", {name: "facetslider"}, []), e("div", {name: "facetslider"}, [])];
            let filterNodes = [];
            let intervals = state.g(STATE_COUNT_FILTER_INTERVALS);

            let range = intervals.source;

            for (let i = 0; i < 2; i++) {
                let sliderNode = sliderNodes[i];

                let range;
                let name;

                if (i == 0) {
                    range = intervals.source;
                    name = "Source Count";
                } else if (i == 1) {
                    range = intervals.target;
                    name = "Target count";
                } else {
                    continue;
                }

                noUiSlider.create(sliderNode, {
                    start: [range[0], range[1]],
                    step: 1,
                    connect: true,
                    range: {
                        'min': range[0],
                        'max': range[1]
                    },
                    pips: {
                        mode: 'range',
                        density: 5,

                    }
                });

                sliderNode.noUiSlider.on("start", function(values, handle) {
                    sliderNode.noUiSlider.updateOptions({tooltips: [true, true]});
                })

                sliderNode.noUiSlider.on("end", function(values, handle) {
                    sliderNode.noUiSlider.updateOptions({tooltips: [false, false]});
                })

                filterNodes.push(e("div", {class: "h-24 w-72"}, [
                    e("div", name),
                    sliderNode
                ]))
            }

            sliderNodes.forEach(sliderNode => {
                sliderNode.noUiSlider.on("slide", function(values, handle) {
                    state.u(STATE_COUNT_FILTER_VALUES, sliderNodes.map(n => n.noUiSlider.get(true)));
                })
            })

            return filterNodes;
        }

        countFilterControls().forEach(element => {
            a(g("chrom-data-counts"), element)
        });

        function render() {
            const scale = state.g(STATE_SCALE);
            const scaleX = state.g(STATE_SCALE_X);
            const scaleY = state.g(STATE_SCALE_Y);
            const viewBox = state.g(STATE_VIEWBOX);
            const zoomed = state.g(STATE_ZOOMED);
            const zoomChromoIndex = state.g(STATE_ZOOM_CHROMO_INDEX);
            let currentLevel = state.g(STATE_COVERAGE_DATA);
            let countIntervals = state.g(STATE_COUNT_FILTER_INTERVALS);
            let sourceCountInterval = countIntervals.source;
            let targetCountInterval = countIntervals.target;

            rc(g("chrom-data"), renderSVG(currentLevel, sourceCountInterval, targetCountInterval, viewBox, scaleX, scaleY, zoomed));
            rc(g("chrom-data-legend"), Legend(d3.scaleSequential(sourceCountInterval, sourceColors), {
                title: "Source Count"
            }));
            a(g("chrom-data-legend"), Legend(d3.scaleSequential(targetCountInterval, targetColors), {
                title: "Target Count"
            }));
        }

        state.ac(STATE_ZOOMED, (s, key) => {
            const zoomed = s[key];
            const scale = zoomed ? 15 : 1;
            const scaleX = zoomed ? 30 : 1;
            const scaleY = zoomed ? 15 : 1;
            state.u(STATE_SCALE, scale);
            state.u(STATE_SCALE_X, scaleX);
            state.u(STATE_SCALE_Y, scaleY);

            if (zoomed) {
                let zoomChromoIndex = state.g(STATE_ZOOM_CHROMO_INDEX);
                let zoomedLevel = coverageData;
                state.u(STATE_COVERAGE_DATA, zoomedLevel);
            } else {
                state.u(STATE_ZOOM_CHROMO_INDEX, undefined);
                state.u(STATE_COVERAGE_DATA, coverageData);
            }
        });

        state.ac(STATE_ALL_FILTERED, (s, key) => {
            render()
        });

        state.ac([STATE_DISCRETE_FACET_VALUES, STATE_CONTINUOUS_FACET_VALUES], _.debounce((s, key) => {
            // Send facet data to server to get filtered data and updated continuous facets
            let filters = { filters: [
                state.g(STATE_DISCRETE_FACET_VALUES),
                state.g(STATE_CONTINUOUS_FACET_VALUES)
            ]}
            postJson("/search/experiment_coverage/{{ experiment.accession_id }}", JSON.stringify(filters)).then(response_json => {
                state.u(STATE_COVERAGE_DATA, response_json.chromosomes);
                state.u(STATE_COUNT_FILTER_INTERVALS, response_json.count_intervals);
                state.u(STATE_COUNT_FILTER_VALUES, [response_json.count_intervals.source, response_json.count_intervals.target]);
                render();
            });
        }, 10));

        state.ac(STATE_COUNT_FILTER_VALUES, _.debounce((s, key) => {
            countFacetWorker.postMessage({data: state.g(STATE_COVERAGE_DATA), countFilters: state.g(STATE_COUNT_FILTER_VALUES)})
        }, 10));

        state.ac(STATE_COUNT_FILTER_INTERVALS, (s, key) => {
            cc(g("chrom-data-counts"));
            countFilterControls().forEach(element => a(g("chrom-data-counts"), element));
        })
    </script>
{% endblock %}
