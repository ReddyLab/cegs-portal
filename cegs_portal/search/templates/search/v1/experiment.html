{% extends "base.html" %}
{% load static i18n %}

{% block css %}
{{ block.super }}
<link href="{% static 'css/nouislider.min.css' %}" rel="stylesheet">
<style>
    .noUi-horizontal {
        height: 10px;
    }

    .noUi-horizontal .noUi-handle {
        width: 20px;
        height: 20px;
    }

    .noUi-handle {
        border-radius: 10px;
    }

    .noUi-handle:before, .noUi-handle:after {
        display: none;
    }

    .noUi-connect {
        background: rgba(1, 33, 105, 1);
    }

    .noUi-pips-horizontal {
        transform: translate(6px);
    }
</style>
{% endblock %}

{% block javascript %}
{{ block.super }}
<script type="text/javascript" src="{% static 'js/lodash.min.js' %}"></script>
<script type="text/javascript" src="{% static 'js/nouislider.min.js' %}"></script>
<script type="text/javascript" src="https://d3js.org/d3.v7.min.js"></script>
{% endblock %}

{% block title %}Experiment{% endblock %}
{% block content %}
    <div class="max-w-5xl">
        <div class="text-2xl font-bold">{{ experiment.accession_id }}: {{ experiment.name }}</div>
        <table class="data-table">
            <tr><th>Description</th><td>{{ experiment.description }}</td></tr>
            <tr><th>Assay</th><td>{{ experiment.experiment_type }}</td></tr>
            <tr><th>Cell Lines</th><td>{{ experiment.cell_lines|join:", " }}</td></tr>
            <tr><th>Tissue Types</th><td>{{ experiment.tissue_types|join:", " }}</td></tr>
            <tr><th>Assemblies</th><td>{{ experiment.assemblies|join:", " }}</td></tr>
        </table>

        {% if experiment.data_files.all|length > 0 %}
        <div>
            <div class="text-xl font-bold">Data Files</div>
            {% for file in experiment.data_files.all %}
            <table class="data-table">
                <tr><th>File Name</th><td>{{ file.filename }}</td></tr>
                <tr><th>Description</th><td>{{ file.description }}</td></tr>
                <tr><th>Cell Lines</th><td>{{ file.cell_lines.all|join:", " }}</td></tr>
                <tr><th>Tissue Types</th><td>{{ file.tissue_types.all|join:", " }}</td></tr>
                <tr><th>Assembly</th><td>{{ file.ref_genome }}.{{ file.ref_genome_patch|default:"0" }}</td></tr>
            </table>
            {% endfor %}
        </div>
        {% endif %}

        {% if experiment.other_files.all|length > 0 %}
        <div>
            <div class="text-xl font-bold">Other Files</div>
            {% for file in experiment.other_files.all %}
            <table class="data-table">
                <tr><th>File Name</th><td>{{ file.filename }}</td></tr>
                <tr><th>Description</th><td>{{ file.description }}</td></tr>
                <tr><th>Location</th><td><a href="{{ file.url }}">{{ file.url }}</a></td></tr>
            </table>
            {% endfor %}
        </div>
        {% endif %}

        <div id="experiment-coverage" class="mt-4">
            <div id="chrom-data-header" class="text-xl font-bold"></div>
            <div class="flex flex-row">
                <div id="chrom-data-filters" class="basis-1/3">
                    <div id="chrom-data-discrete-facets"></div>
                    <div id="chrom-data-continuous-facets"></div>
                    <div id="chrom-data-counts"></div>
                </div>
                <div class="basis-2/3">
                    <div id="chrom-data-legend"></div>
                    <div id="chrom-data"></div>
                </div>
            </div>
        </div>
    </div>
{% endblock %}

{% block inline_javascript %}
    <script type="module">
        import { a, cc, e, g, rc, t } from "{% static 'search/js/dom.js' %}";
        import { State } from "{% static 'search/js/state.js' %}";
        import { getJson } from "{% static 'search/js/files.js' %}";
        import { Legend } from "{% static 'search/js/obsLegend.js' %}";
        let genome;
        let level1;
        let level2;
        try {
            genome = await getJson("{% get_static_prefix %}search/experiments/{{ experiment.accession_id }}/grch37.json");
            level1 = await getJson("{% get_static_prefix %}search/experiments/{{ experiment.accession_id }}/level1_data.json");
            level2 = [
                await getJson("{% get_static_prefix %}search/experiments/{{experiment.accession_id}}/level2_1.json"),
                await getJson("{% get_static_prefix %}search/experiments/{{experiment.accession_id}}/level2_2.json"),
                await getJson("{% get_static_prefix %}search/experiments/{{experiment.accession_id}}/level2_3.json"),
                await getJson("{% get_static_prefix %}search/experiments/{{experiment.accession_id}}/level2_4.json"),
                await getJson("{% get_static_prefix %}search/experiments/{{experiment.accession_id}}/level2_5.json"),
                await getJson("{% get_static_prefix %}search/experiments/{{experiment.accession_id}}/level2_6.json"),
                await getJson("{% get_static_prefix %}search/experiments/{{experiment.accession_id}}/level2_7.json"),
                await getJson("{% get_static_prefix %}search/experiments/{{experiment.accession_id}}/level2_8.json"),
                await getJson("{% get_static_prefix %}search/experiments/{{experiment.accession_id}}/level2_9.json"),
                await getJson("{% get_static_prefix %}search/experiments/{{experiment.accession_id}}/level2_10.json"),
                await getJson("{% get_static_prefix %}search/experiments/{{experiment.accession_id}}/level2_11.json"),
                await getJson("{% get_static_prefix %}search/experiments/{{experiment.accession_id}}/level2_12.json"),
                await getJson("{% get_static_prefix %}search/experiments/{{experiment.accession_id}}/level2_13.json"),
                await getJson("{% get_static_prefix %}search/experiments/{{experiment.accession_id}}/level2_14.json"),
                await getJson("{% get_static_prefix %}search/experiments/{{experiment.accession_id}}/level2_15.json"),
                await getJson("{% get_static_prefix %}search/experiments/{{experiment.accession_id}}/level2_16.json"),
                await getJson("{% get_static_prefix %}search/experiments/{{experiment.accession_id}}/level2_17.json"),
                await getJson("{% get_static_prefix %}search/experiments/{{experiment.accession_id}}/level2_18.json"),
                await getJson("{% get_static_prefix %}search/experiments/{{experiment.accession_id}}/level2_19.json"),
                await getJson("{% get_static_prefix %}search/experiments/{{experiment.accession_id}}/level2_20.json"),
                await getJson("{% get_static_prefix %}search/experiments/{{experiment.accession_id}}/level2_21.json"),
                await getJson("{% get_static_prefix %}search/experiments/{{experiment.accession_id}}/level2_22.json"),
                await getJson("{% get_static_prefix %}search/experiments/{{experiment.accession_id}}/level2_X.json"),
                await getJson("{% get_static_prefix %}search/experiments/{{experiment.accession_id}}/level2_Y.json"),
                await getJson("{% get_static_prefix %}search/experiments/{{experiment.accession_id}}/level2_MT.json"),
            ]
        } catch (error) {
            // If the files can't be loaded we don't want to even try to show the visualization.
        }

        const ccreColors = d3.interpolateCool;
        const geneColors = d3.interpolateWarm;
        const xInset = 60;
        const yInset = 100;
        const chromHeight = 98;
        const chromSpacing = 10;
        const maxPxChromWidth = 2048;
        const maxChromSize = genome.reduce((a, c) => c.size > a ? c.size : a, 0);
        const viewWidth = maxPxChromWidth + (xInset * 2)
        const viewHeight = (yInset * 2) + (chromHeight + chromSpacing) * genome.length
        const bandColors = {
            acen: '#708090',
            gneg: '#FFFFFF',
            gpos: '#000000',
            gpos100: '#000000',
            gpos25: '#D9D9D9',
            gpos33: '#BFBFBF',
            gpos50: '#999999',
            gpos66: '#7F7F7F',
            gpos75: '#666666',
            gvar: '#E0E0E0',
            stalk: '#708090'
        };
        const svgns = "http://www.w3.org/2000/svg";

        const STATE_ZOOMED = "state-zoomed";
        const STATE_ZOOM_CHROMO_INDEX = "state-zoom-chromo-index";
        const STATE_SCALE = "state-scale";
        const STATE_SCALE_X = "state-scale-x";
        const STATE_SCALE_Y = "state-scale-y";
        const STATE_VIEWBOX = "state-viewbox";
        const STATE_DISCRETE_FACET_VALUES = "state-discrete-facets"
        const STATE_CONTINUOUS_FACET_VALUES = "state-continuous-facets";
        const STATE_COUNT_FILTER_VALUES = "state-count-filter";
        const STATE_NON_FILTERED = "state-no-filtered";
        const STATE_DISCRETE_FILTERED = "state-discrete-filtered";
        const STATE_CONTINUOUS_FILTERED = "state-continuous-filtered"
        const STATE_ALL_FILTERED = "state-all-filtered";
        const STATE_CONTINUOUS_FILTER_INTERVALS = "state-continuous-filter-intervals";
        const STATE_COUNT_FILTER_INTERVALS = "state-count-filter-intervals";

        let cCRECountInterval = levelCountInterval(level1, "ccre_intervals", "ccres");
        let geneCountInterval = levelCountInterval(level1, "gene_intervals", "genes");
        let effectSizeInterval = regEffectDataInterval(level1, 1)
        let sigInterval = regEffectDataInterval(level1, 2)
        let state = new State({
            [STATE_ZOOMED]: false,
            [STATE_ZOOM_CHROMO_INDEX]: undefined,
            [STATE_SCALE]: 1,
            [STATE_SCALE_X]: 1,
            [STATE_SCALE_Y]: 1,
            [STATE_VIEWBOX]: [0, 0, viewWidth, viewHeight],
            [STATE_DISCRETE_FACET_VALUES]: [],
            [STATE_CONTINUOUS_FACET_VALUES]: [effectSizeInterval, sigInterval],
            [STATE_COUNT_FILTER_VALUES]: [cCRECountInterval, geneCountInterval],
            [STATE_NON_FILTERED]: level1,
            [STATE_DISCRETE_FILTERED]: level1,
            [STATE_CONTINUOUS_FILTERED]: level1,
            [STATE_ALL_FILTERED]: level1,
            [STATE_CONTINUOUS_FILTER_INTERVALS]: {effectSize: effectSizeInterval, significance: sigInterval},
            [STATE_COUNT_FILTER_INTERVALS]: {ccre: cCRECountInterval, gene: geneCountInterval}
        });

        class Tooltip {
            constructor() {
                this._count = document.createElementNS(svgns, "text");
                this._count.setAttribute("y", "-32");
                this._range = document.createElementNS(svgns, "text");
                this._range.setAttribute("y", "-20");
                this.node = document.createElementNS(svgns, "g");
                this.node.setAttribute("pointer-events", "none");
                this.node.setAttribute("display", "none");
                this.node.setAttribute("font-family", "sans-serif");
                this.node.setAttribute("font-size", "12");
                this.node.setAttribute("text-anchor", "middle");
                this._rect = document.createElementNS(svgns, "rect");
                this._rect.setAttribute("x", "-85");
                this._rect.setAttribute("width", "170");
                this._rect.setAttribute("y", "-50");
                this._rect.setAttribute("height", "40");
                this._rect.setAttribute("fill", "white");
                this.node.appendChild(this._rect);
                this.node.appendChild(this._count);
                this.node.appendChild(this._range);
            }

            show(chomIdx, d) {
                let scaleX = state.g(STATE_SCALE_X);
                let scaleY = state.g(STATE_SCALE_Y);
                this.node.removeAttribute("display");
                this.node.setAttribute("transform", `translate(${xInset + toPx(d.start) * scaleX}, ${yInset + (chomIdx * (chromHeight + chromSpacing) * scaleY)}) scale(2)`);
                this._count.textContent = `Ct: ${(d.ccres || d.genes).length}`;
                this._range.textContent = `Loc: (${d.start}, ${d.end})`;
            }

            hide() {
                this.node.setAttribute("display", "none");
            }
        }

        const tooltip = new Tooltip();

        rc(g("chrom-data-header"), t("Experiment Coverage"));

        render();

        function renderSVG(currentLevel, cCRECountInterval, geneCountInterval, viewBox, scaleX, scaleY, zoomed) {
            const bucketHeight = 44 * scaleY;
            const cCRECountRange = cCRECountInterval[1] - cCRECountInterval[0];
            const geneCountRange = geneCountInterval[1] - geneCountInterval[0];

            const svg = d3.create("svg")
                .attr("stroke", "black")
                .attr("viewBox", viewBox)
                .style("max-width", `${maxPxChromWidth + 20}px`)
                .style("display", "block")
                .style("margin", "auto");

            let chromGroups = [];
            for (let i = 0; i < genome.length; i++) {
                const frame = svg.append("g");
                chromGroups.push(frame);
                const chrom = frame.append("g");
                chrom.selectAll("path")
                .data(genome[i].bands)
                .join("path")
                    .attr("fill", b => bandColors[b.type])
                    .attr("fill-opacity", 0.3)
                    .attr("stroke", "none")
                    .attr("d", chromosomeBand(i));
                chrom.append("path")
                    .attr("stroke-width", 1)
                    .attr("stroke", "black")
                    .attr("fill", "none")
                    .attr("d", chromosomeOutline(genome[i], i));
            }

            let nameGroup = svg.append("g")
            nameGroup.selectAll("text")
            .data(currentLevel.chromosomes)
            .join("text")
                .attr("x", 0)
                .attr("y", (chromo, i) => yInset  + ((chromHeight / 2) + (chromSpacing + chromHeight) * i) * scaleY)
                .attr("font-size", Math.max(Math.ceil(14 * (scaleY * 0.3)), 32))
                .text(chromo => chromo.chrom)

            for (let i = 0; i < currentLevel.chromosomes.length; i++) {
                const bucketSize = currentLevel.chromosomes[i].bucket_size;
                const bucketWidth = toPx(bucketSize) * scaleX;

                const frame = chromGroups[i];
                const ccreOverlay = frame.append("g");
                ccreOverlay.attr("stroke", "none");

                let ccreRects = ccreOverlay.selectAll("rect")
                .data(currentLevel.chromosomes[i].ccre_intervals.filter(ccre => ccre.ccres.length > 0))
                .join("rect")
                    .attr("fill", ccre => ccreColors((ccre.ccres.length - cCRECountInterval[0]) / cCRECountRange))
                    .attr("x", ccre => xInset + toPx(ccre.start) * scaleX)
                    .attr("y", yInset + (chromSpacing + chromHeight) * i * scaleY)
                    .attr("width", bucketWidth)
                    .attr("height", bucketHeight);

                const geneOverlay = frame.append("g");
                geneOverlay.attr("stroke", "none");
                let geneRects = geneOverlay.selectAll("rect")
                    .data(currentLevel.chromosomes[i].gene_intervals.filter(gene => gene.genes.length > 0))
                    .join("rect")
                    .attr("fill", gene => geneColors((gene.genes.length - geneCountInterval[0]) / geneCountRange))
                    .attr("x", gene => xInset + toPx(gene.start) * scaleX)
                    .attr("y", yInset + (54 + (chromSpacing + chromHeight) * i) * scaleY)
                    .attr("width", bucketWidth)
                    .attr("height", bucketHeight);

                let mouseLeave = () => {
                    ccreRects.attr("stroke", null);
                    ccreRects.attr("stroke-width", null);
                    geneRects.attr("stroke", null);
                    geneRects.attr("stroke-width", null);
                    tooltip.hide();
                }

                let click = (i, start) => {
                    if(zoomed) {
                        state.u(STATE_VIEWBOX, [0, 0, viewWidth, viewHeight]);
                    } else {
                        state.u(STATE_VIEWBOX, [
                            xInset + toPx(start) * 30 - viewHeight / 6,
                            yInset + (chromHeight + chromSpacing) * i * 15 - viewHeight / 6,
                            viewWidth,
                            viewHeight
                        ]);
                        state.u(STATE_ZOOM_CHROMO_INDEX, i);
                    }
                    state.u(STATE_ZOOMED, !zoomed);
                }

                ccreRects.on("mouseenter", (event, rect) => {
                    ccreRects.attr("stroke", node => node.start == rect.start ? "red" : null);
                    ccreRects.attr("stroke-width", node => node.start == rect.start ? 8 : null);

                    let gene_buckets = new Set()
                    for(const ccre of rect.ccres) {
                        for (const gene_bucket of ccre[1]){
                            gene_buckets.add(gene_bucket);
                        }
                    }

                    geneRects.attr("stroke", function(node) {
                        if(gene_buckets.has((node.start - 1) / bucketSize)) {
                            return "yellow";
                        }
                        return null
                    });
                    geneRects.attr("stroke-width", function(node) {
                        if(gene_buckets.has((node.start - 1) / bucketSize)) {
                            return 8;
                        }
                        return null
                    });
                    rect.end = rect.start + bucketSize;
                    tooltip.show(i, rect);
                })
                .on("mouseleave", (event, rect) => {
                    mouseLeave();
                })
                .on("click", (event, rect) => {
                    click(i, rect.start);
                });

                geneRects.on("mouseenter", (event, rect) => {
                    geneRects.attr("stroke", node => node.start == rect.start ? "red" : null);
                    geneRects.attr("stroke-width", node => node.start == rect.start ? 8 : null);

                    let ccre_buckets = new Set()
                    for(const gene of rect.genes) {
                        for (const ccre_bucket of gene[1]){
                            ccre_buckets.add(ccre_bucket);
                        }
                    }

                    ccreRects.attr("stroke", function(node) {
                        if(ccre_buckets.has((node.start - 1) / bucketSize)) {
                            return "yellow";
                        }
                        return null
                    });
                    ccreRects.attr("stroke-width", function(node) {
                        if(ccre_buckets.has((node.start - 1) / bucketSize)) {
                            return 8;
                        }
                        return null
                    });
                    rect.end = rect.start + bucketSize;
                    tooltip.show(i, rect);
                })
                .on("mouseleave", (event, rect) => {
                    mouseLeave();
                })
                .on("click", (event, rect) => {
                    click(i, rect.start);
                });
            }

            svg.append(() => tooltip.node);

            return svg.node();
        }

        function chromosomeOutline(d, i) {
            const scale = state.g(STATE_SCALE);
            const scaleX = state.g(STATE_SCALE_X);
            const scaleY = state.g(STATE_SCALE_Y);
            const width = toPx(d.size) * scaleX;
            const top = yInset + (chromSpacing + chromHeight) * i * scaleY;
            const bottom = top + chromHeight * scaleY;
            const outlinePath = ["M", xInset, ",", top];
            outlinePath.push(
                "C", xInset - (12 * scale) ,",", top, " ",
                xInset - (12 * scale) , ",", bottom, " ",
                xInset, ",", bottom,
            );
            outlinePath.push("M", xInset + width ,",", top);
            outlinePath.push(
                "C", xInset + width + (12 * scale) ,",", top, " ",
                xInset + width + (12 * scale) , ",", bottom, " ",
                xInset + width, ",", bottom,
            );

            for(const band of d.bands) {
                let bandStart = band.start < band.end ? band.start : band.end;
                let bandEnd = band.start > band.end ? band.start : band.end;
                let bandPxStart = toPx(bandStart) * scaleX;
                let bandPxEnd = toPx(bandEnd) * scaleX;
                let bandPxWidth = bandPxEnd - bandPxStart;

                if(band.type == "acen") {
                    if(band.id.startsWith("p")) {
                        outlinePath.push("M", xInset + bandPxStart ,",", top);
                        outlinePath.push("l", bandPxWidth, ",", chromHeight / 2 * scaleY);
                        outlinePath.push("l", -bandPxWidth, ",", chromHeight / 2 * scaleY);
                    } else {
                        outlinePath.push("M", xInset + bandPxEnd ,",", top);
                        outlinePath.push("l", -bandPxWidth, ",", chromHeight / 2 * scaleY);
                        outlinePath.push("l", bandPxWidth, ",", chromHeight / 2 * scaleY);
                    }
                } else {
                    outlinePath.push("M", xInset + bandPxStart ,",", top);
                    outlinePath.push("l", bandPxWidth, ",", 0);
                    outlinePath.push("M", xInset + bandPxStart ,",", bottom);
                    outlinePath.push("l", bandPxWidth, ",", 0);
                }
            }

            return outlinePath.join("");
        }

        function chromosomeBand(chromIndex) {
            return function(band) {
                const scaleX = state.g(STATE_SCALE_X);
                const scaleY = state.g(STATE_SCALE_Y);
                const top = yInset + (chromSpacing + chromHeight) * chromIndex * scaleY;
                const bottom = top + chromHeight * scaleY;
                let bandStart = band.start < band.end ? band.start : band.end;
                let bandPxStart = toPx(bandStart) * scaleX;
                let bandEnd = band.start > band.end ? band.start : band.end;
                let bandPxEnd = toPx(bandEnd) * scaleX;
                let bandSize = bandEnd - bandStart;
                let bandPxWidth = bandPxEnd - bandPxStart;
                let outlinePath = ["M", xInset + bandPxStart, ",", top];
                if(band.type == "acen") {
                    if(band.id.startsWith("p")) {
                        outlinePath.push("M", xInset + bandPxStart ,",", top);
                        outlinePath.push("l", bandPxWidth, ",", chromHeight / 2 * scaleY);
                        outlinePath.push("l", -bandPxWidth, ",", chromHeight / 2 * scaleY);
                    } else {
                        outlinePath.push("M", xInset + bandPxEnd ,",", top);
                        outlinePath.push("l", -bandPxWidth, ",", chromHeight / 2 * scaleY);
                        outlinePath.push("l", bandPxWidth, ",", chromHeight / 2 * scaleY);
                    }
                } else {
                    outlinePath.push("l", 0, ",", chromHeight * scaleY);
                    outlinePath.push("l", bandPxWidth, ",", 0);
                    outlinePath.push("l", 0, ",", -chromHeight * scaleY);
                    outlinePath.push("l", -bandPxWidth, ",", 0);
                }

                return outlinePath.join("");
            }
        }

        function toPx(size) {
            return maxPxChromWidth * (size / maxChromSize);
        }

        function levelCountInterval(data, interval, item, chromoIndex) {
            let chroms = data.chromosomes;
            if (chromoIndex) {
                chroms = [chroms[chromoIndex]];
            }
            let max = Number.NEGATIVE_INFINITY;
            let min = Number.POSITIVE_INFINITY;
            for (const chrom of chroms) {
                const count = chrom[interval].map(d => d[item].length);
                max = Math.max(max, Math.max(...count));
                min = Math.min(min, Math.min(...count));
            }

            if (max == Number.NEGATIVE_INFINITY || min == Number.POSITIVE_INFINITY) {
                return [0, 0];
            }

            return [min, max];
        }

        function regEffectDataInterval(data, dataOffset, chromoIndex) {
            let chroms = data.chromosomes;
            if (chromoIndex) {
                chroms = [chroms[chromoIndex]];
            }
            let max = Number.NEGATIVE_INFINITY;
            let min = Number.POSITIVE_INFINITY;
            for (const chrom of chroms) {
                for (const geneInterval of chrom.gene_intervals) {
                    for (const gene of geneInterval.genes) {
                        let contFacetCount = gene[0][0];
                        for (let i = 1; i < gene[0].length;) {
                            let discreteFacetCount = gene[0][i]
                            max = Math.max(max, gene[0][i + discreteFacetCount + dataOffset]);
                            min = Math.min(min, gene[0][i + discreteFacetCount + dataOffset]);
                            i += discreteFacetCount + contFacetCount + 1;
                        }
                    }
                }
                for (const ccreInterval of chrom.ccre_intervals) {
                    for (const ccre of ccreInterval.ccres) {
                        let contFacetCount = ccre[0][0];
                        for (let i = 1; i < ccre[0].length;) {
                            let discreteFacetCount = ccre[0][i]
                            max = Math.max(max, ccre[0][i + discreteFacetCount + dataOffset]);
                            min = Math.min(min, ccre[0][i + discreteFacetCount + dataOffset]);
                            i += discreteFacetCount + contFacetCount + 1;
                        }
                    }
                }
            }

            if (max == Number.NEGATIVE_INFINITY || min == Number.POSITIVE_INFINITY) {
                return [0, 0];
            }

            return [min, max];
        }

        function discreteFilterControls(facets) {
            return facets
            .filter(f => f.type == "FacetType.DISCRETE")
            .map(facet => {
                return e("fieldset", {name: "facetfield", class:"my-4"}, [
                    e("legend", {class:"font-bold"}, facet.name),
                    e("div", {class: "flex flex-row flex-wrap gap-1"},
                    Object.entries(facet.values).map(entry => {
                        return e("div", {class:"ml-1"}, [
                            e("input", {type:"checkbox", id:entry[0], name:facet.name}, []),
                            e("label", {for:entry[0]}, entry[1])
                        ])
                    })
                    )
                ])
            });
        }

        discreteFilterControls(level1.facets).forEach(element => {
            a(g("chrom-data-discrete-facets"), element)
        });

        const discreteFacets = g("chrom-data-discrete-facets");
        const facetCheckboxes = discreteFacets.querySelectorAll("input[type=checkbox]");

        facetCheckboxes.forEach(checkbox => {
            checkbox.addEventListener("change", _ => {
                let checkedFacets = Array.from(facetCheckboxes) // Convert checkboxes to an array to use filter and map.
                                    .filter(i => i.checked) // Use Array.filter to remove unchecked checkboxes.
                                    .map(i => Number(i.id))
                state.updateSharedState(STATE_DISCRETE_FACET_VALUES, checkedFacets);
            });
        });

        function discreteFacetFilter(data, discreteFacetIds) {
            if (discreteFacetIds.length == 0) {
                return {data, effectSizeInterval, sigInterval};
            }

            let facets = new Set(discreteFacetIds);
            let geneFacets = level1.facets
                .filter(f => f.type == "FacetType.DISCRETE" && f.coverage.includes("gene"))
                .map(f => Object.keys(f.values).map(k => Number.parseInt(k)));

            let cCREFacets = level1.facets
                .filter(f => f.type == "FacetType.DISCRETE" && f.coverage.includes("ccre"))
                .map(f => Object.keys(f.values).map(k => Number.parseInt(k)));

            let geneFacetsWithSelections = geneFacets.filter(gf => _.intersection(gf, discreteFacetIds).length > 0);
            let cCREFacetsWithSelections = cCREFacets.filter(cf => _.intersection(cf, discreteFacetIds).length > 0);

            let selectedGeneFacets = geneFacets.map(gf => _.intersection(gf, discreteFacetIds)).filter(gf => _.intersection(gf, discreteFacetIds).length > 0);
            let selectedcCREFacets = cCREFacets.map(cf => _.intersection(cf, discreteFacetIds)).filter(cf => _.intersection(cf, discreteFacetIds).length > 0);

            let minEffect = Number.POSITIVE_INFINITY;
            let maxEffect = Number.NEGATIVE_INFINITY;

            let minSig = Number.POSITIVE_INFINITY;
            let maxSig = Number.NEGATIVE_INFINITY;

            for (let cIdx = 0; cIdx < data.chromosomes.length; cIdx++) {
                if (geneFacetsWithSelections.length > 0) {
                    const gene_intervals_len = data.chromosomes[cIdx].gene_intervals.length;
                    for (let iIdx = 0; iIdx < gene_intervals_len; iIdx++) {
                        const genes = data.chromosomes[cIdx].gene_intervals[iIdx].genes;
                        const genes_len = genes.length;
                        let newGenes = [];
                        for (let gIdx = 0; gIdx < genes_len; gIdx++) {
                            let regEffects = genes[gIdx][0];
                            const contFacetCount = regEffects[0];
                            let newRegEffects = [contFacetCount];
                            for (let rIdx = 1; rIdx < regEffects.length;) {
                                const discFacetCount = regEffects[rIdx];
                                const discFacets = regEffects.slice(rIdx + 1, rIdx + 1 + discFacetCount);
                                const contFacets = regEffects.slice(rIdx + 1 + discFacetCount, rIdx + 1 + discFacetCount + contFacetCount);
                                const effectSize = regEffects[rIdx + 1 + discFacetCount];
                                const significance = regEffects[rIdx + 1 + discFacetCount + 1];

                                if (selectedGeneFacets.every(gf => _.intersection(gf, discFacets).length > 0)) {
                                    maxEffect = maxEffect > effectSize ? maxEffect : effectSize;
                                    minEffect = minEffect < effectSize ? minEffect : effectSize;
                                    maxSig = maxSig > significance ? maxSig : significance;
                                    minSig = minSig < significance ? minSig : significance;
                                    newRegEffects.push(discFacetCount, ...discFacets, ...contFacets);
                                }
                                rIdx += 1 + discFacetCount + contFacetCount;
                            }

                            if (newRegEffects.length > 1) {
                                newGenes.push([newRegEffects, genes[gIdx][1]]);
                            }
                        }
                        data.chromosomes[cIdx].gene_intervals[iIdx].genes = newGenes;
                    }
                }

                if (cCREFacetsWithSelections.length > 0) {
                    const ccre_intervals_len = data.chromosomes[cIdx].ccre_intervals.length;
                    for (let iIdx = 0; iIdx < ccre_intervals_len; iIdx++) {
                        const ccres = data.chromosomes[cIdx].ccre_intervals[iIdx].ccres
                        const ccres_len = ccres.length;

                        let newcCREs = [];
                        for (let gIdx = 0; gIdx < ccres_len; gIdx++) {
                            const regEffects = ccres[gIdx][0];
                            const contFacetCount = regEffects[0];
                            let newRegEffects = [contFacetCount];
                            for (let rIdx = 1; rIdx < regEffects.length;) {
                                const discFacetCount = regEffects[rIdx];
                                const discFacets = regEffects.slice(rIdx + 1, rIdx + 1 + discFacetCount);
                                const contFacets = regEffects.slice(rIdx + 1 + discFacetCount, rIdx + 1 + discFacetCount + contFacetCount);
                                const effectSize = regEffects[rIdx + 1 + discFacetCount];
                                const significance = regEffects[rIdx + 1 + discFacetCount + 1];

                                if (selectedcCREFacets.every(cf => _.intersection(cf, discFacets).length > 0)) {
                                    maxEffect = maxEffect > effectSize ? maxEffect : effectSize;
                                    minEffect = minEffect < effectSize ? minEffect : effectSize;
                                    maxSig = maxSig > significance ? maxSig : significance;
                                    minSig = minSig < significance ? minSig : significance;

                                    newRegEffects.push(discFacetCount, ...discFacets, ...contFacets);
                                }
                                rIdx += 1 + discFacetCount + contFacetCount;
                            }

                            if (newRegEffects.length > 1) {
                                newcCREs.push([newRegEffects, ccres[gIdx][1]]);
                            }
                        }
                        data.chromosomes[cIdx].ccre_intervals[iIdx].ccres = newcCREs;
                    }
                }
            }
            minEffect = minEffect === Number.POSITIVE_INFINITY ? effectSizeInterval[0] : minEffect;
            maxEffect = maxEffect === Number.NEGATIVE_INFINITY ? effectSizeInterval[1] : maxEffect;
            minSig = minSig === Number.POSITIVE_INFINITY ? sigInterval[0] : minSig;
            maxSig = maxSig === Number.NEGATIVE_INFINITY ? sigInterval[1] : maxSig;

            return {data, effectSizeInterval: [minEffect, maxEffect], sigInterval: [minSig, maxSig]}
        }

        function continuousFilterControls() {
            const contFacets = level1.facets.filter(f => f.type == "FacetType.CONTINUOUS");
            let sliderNodes = [e("div", {name: "facetslider"}, []), e("div", {name: "facetslider"}, [])];
            let filterNodes = [];
            let intervals = state.g(STATE_CONTINUOUS_FILTER_INTERVALS);

            for (let i = 0; i < contFacets.length; i++) {
                let facet = contFacets[i];
                let sliderNode = sliderNodes[i];

                let range;

                if (facet.name === "Effect Size") {
                    range = intervals.effectSize;
                } else if (facet.name === "Significance") {
                    range = intervals.significance;
                } else {
                    continue;
                }

                noUiSlider.create(sliderNode, {
                    start: [range[0], range[1]],
                    format: {
                        to: n => n.toPrecision(3),
                        from: s => Number.parseFloat(s)
                    },
                    connect: true,
                    range: {
                        'min': range[0],
                        'max': range[1]
                    },
                    pips: {
                        mode: 'range',
                        density: 5,
                        format: {
                            to: n => n.toPrecision(3),
                            from: s => Number.parseFloat(s)
                        }
                    }
                });

                sliderNode.noUiSlider.on("start", function(values, handle) {
                    sliderNode.noUiSlider.updateOptions({tooltips: [true, true]});
                })

                sliderNode.noUiSlider.on("end", function(values, handle) {
                    sliderNode.noUiSlider.updateOptions({tooltips: [false, false]});
                })

                filterNodes.push(e("div", {class: "h-24 w-72"}, [
                    e("div", facet.name),
                    sliderNode
                ]))
            }

            sliderNodes.forEach(sliderNode => {
                sliderNode.noUiSlider.on("slide", function(values, handle) {
                    state.u(STATE_CONTINUOUS_FACET_VALUES, sliderNodes.map(n => n.noUiSlider.get(true)));
                })
            })

            return filterNodes;
        }

        continuousFilterControls().forEach(element => {
            a(g("chrom-data-continuous-facets"), element)
        });

        function continuousFacetFilter(data, continuousFilters) {
            const effectSizeRange = continuousFilters[0];
            const sigRange = continuousFilters[1];

            for (let cIdx = 0; cIdx < data.chromosomes.length; cIdx++) {
                const gene_intervals = data.chromosomes[cIdx].gene_intervals;
                for (let iIdx = 0; iIdx < gene_intervals.length; iIdx++) {
                    const genes = gene_intervals[iIdx].genes;
                    let newGenes = [];
                    for (let gIdx = 0; gIdx < genes.length; gIdx++) {
                        let regEffects = genes[gIdx][0];
                        let contFacetCount = regEffects[0];
                        let newRegEffects = [contFacetCount];
                        for (let rIdx = 1; rIdx < regEffects.length;) {
                            const discFacetCount = regEffects[rIdx];
                            const discFacets = regEffects.slice(rIdx + 1, rIdx + 1 + discFacetCount);
                            const contFacets = regEffects.slice(rIdx + 1 + discFacetCount, rIdx + 1 + discFacetCount + contFacetCount);
                            const effectSize = regEffects[rIdx + 1 + discFacetCount];
                            const significance = regEffects[rIdx + 1 + discFacetCount + 1];

                            if ((effectSize >= effectSizeRange[0] && effectSize <= effectSizeRange[1]) &&
                                (significance >= sigRange[0] && significance <= sigRange[1])) {
                                newRegEffects.push(discFacetCount, ...discFacets, ...contFacets);
                            }
                            rIdx += 1 + discFacetCount + contFacetCount;
                        }

                        if (newRegEffects.length > 1) {
                            newGenes.push([newRegEffects, genes[gIdx][1]]);
                        }
                    }
                    data.chromosomes[cIdx].gene_intervals[iIdx].genes = newGenes;
                }

                const ccre_intervals = data.chromosomes[cIdx].ccre_intervals;
                for (let iIdx = 0; iIdx < ccre_intervals.length; iIdx++) {
                    const ccres = ccre_intervals[iIdx].ccres;
                    let newcCREs = [];
                    for (let gIdx = 0; gIdx < ccres.length; gIdx++) {
                        let regEffects = ccres[gIdx][0];
                        let contFacetCount = regEffects[0];
                        let newRegEffects = [contFacetCount];
                        for (let rIdx = 1; rIdx < regEffects.length;) {
                            const discFacetCount = regEffects[rIdx];
                            const discFacets = regEffects.slice(rIdx + 1, rIdx + 1 + discFacetCount);
                            const contFacets = regEffects.slice(rIdx + 1 + discFacetCount, rIdx + 1 + discFacetCount + contFacetCount);
                            const effectSize = regEffects[rIdx + 1 + discFacetCount];
                            const significance = regEffects[rIdx + 1 + discFacetCount + 1];

                            if ((effectSize >= effectSizeRange[0] && effectSize <= effectSizeRange[1]) &&
                                (significance >= sigRange[0] && significance <= sigRange[1])) {
                                newRegEffects.push(discFacetCount, ...discFacets, ...contFacets);
                            }
                            rIdx += 1 + discFacetCount + contFacetCount;
                        }

                        if (newRegEffects.length > 1) {
                            newcCREs.push([newRegEffects, ccres[gIdx][1]]);
                        }
                    }
                    data.chromosomes[cIdx].ccre_intervals[iIdx].ccres = newcCREs;
                }
            }

            return data;
        }

        function countFilterControls() {
            let sliderNodes = [e("div", {name: "facetslider"}, []), e("div", {name: "facetslider"}, [])];
            let filterNodes = [];
            let intervals = state.g(STATE_COUNT_FILTER_INTERVALS);

            let range = intervals.ccre;

            for (let i = 0; i < 2; i++) {
                let sliderNode = sliderNodes[i];

                let range;
                let name;

                if (i == 0) {
                    range = intervals.ccre;
                    name = "cCRE Count";
                } else if (i == 1) {
                    range = intervals.gene;
                    name = "Gene count";
                } else {
                    continue;
                }

                noUiSlider.create(sliderNode, {
                    start: [range[0], range[1]],
                    step: 1,
                    connect: true,
                    range: {
                        'min': range[0],
                        'max': range[1]
                    },
                    pips: {
                        mode: 'range',
                        density: 5,

                    }
                });

                sliderNode.noUiSlider.on("start", function(values, handle) {
                    sliderNode.noUiSlider.updateOptions({tooltips: [true, true]});
                })

                sliderNode.noUiSlider.on("end", function(values, handle) {
                    sliderNode.noUiSlider.updateOptions({tooltips: [false, false]});
                })

                filterNodes.push(e("div", {class: "h-24 w-72"}, [
                    e("div", name),
                    sliderNode
                ]))
            }

            sliderNodes.forEach(sliderNode => {
                sliderNode.noUiSlider.on("slide", function(values, handle) {
                    state.u(STATE_COUNT_FILTER_VALUES, sliderNodes.map(n => n.noUiSlider.get(true)));
                })
            })

            return filterNodes;
        }

        countFilterControls().forEach(element => {
            a(g("chrom-data-counts"), element)
        });

        function countFacetFilter(data, countFilters) {
            let ccreFilter = countFilters[0];
            let geneFilter = countFilters[1];

            for (let cIdx = 0; cIdx < data.chromosomes.length; cIdx++) {
                data.chromosomes[cIdx].gene_intervals = data.chromosomes[cIdx].gene_intervals.filter(inter => {
                    return inter.genes.length >= geneFilter[0] && inter.genes.length <= geneFilter[1];
                });
                data.chromosomes[cIdx].ccre_intervals = data.chromosomes[cIdx].ccre_intervals.filter(inter => {
                    return inter.ccres.length >= ccreFilter[0] && inter.ccres.length <= ccreFilter[1];
                });
            }

            return data;
        }

        function render() {
            const scale = state.g(STATE_SCALE);
            const scaleX = state.g(STATE_SCALE_X);
            const scaleY = state.g(STATE_SCALE_Y);
            const viewBox = state.g(STATE_VIEWBOX);
            const zoomed = state.g(STATE_ZOOMED);
            const zoomChromoIndex = state.g(STATE_ZOOM_CHROMO_INDEX);
            let currentLevel = state.g(STATE_ALL_FILTERED);
            let countIntervals = state.g(STATE_COUNT_FILTER_INTERVALS);
            let cCRECountInterval = countIntervals.ccre;
            let geneCountInterval = countIntervals.gene;

            rc(g("chrom-data"), renderSVG(currentLevel, cCRECountInterval, geneCountInterval, viewBox, scaleX, scaleY, zoomed));
            rc(g("chrom-data-legend"), Legend(d3.scaleSequential(cCRECountInterval, ccreColors), {
                title: "cCRE Count"
            }));
            a(g("chrom-data-legend"), Legend(d3.scaleSequential(geneCountInterval, geneColors), {
                title: "Gene Count"
            }));
        }

        state.ac(STATE_ZOOMED, (s, key) => {
            const zoomed = s[key];
            const scale = zoomed ? 15 : 1;
            const scaleX = zoomed ? 30 : 1;
            const scaleY = zoomed ? 15 : 1;
            state.u(STATE_SCALE, scale);
            state.u(STATE_SCALE_X, scaleX);
            state.u(STATE_SCALE_Y, scaleY);

            if (zoomed) {
                let zoomChromoIndex = state.g(STATE_ZOOM_CHROMO_INDEX);
                let zoomedLevel = _.cloneDeep(level1);
                zoomedLevel.chromosomes[zoomChromoIndex] = level2[zoomChromoIndex].chromosomes[0];
                state.u(STATE_NON_FILTERED, zoomedLevel);
            } else {
                state.u(STATE_ZOOM_CHROMO_INDEX, undefined);
                state.u(STATE_NON_FILTERED, level1);
            }
        });

        state.ac([STATE_NON_FILTERED, STATE_DISCRETE_FACET_VALUES], (s, key) => {
            const currentLevel = state.g(STATE_NON_FILTERED);
            let filteredData = _.cloneDeep(currentLevel);
            let df = discreteFacetFilter(filteredData, state.g(STATE_DISCRETE_FACET_VALUES))
            state.u(STATE_DISCRETE_FILTERED, df.data);
            const continuousIntervals = {
                effectSize: df.effectSizeInterval,
                significance: df.sigInterval
            };

            state.u(STATE_CONTINUOUS_FILTER_INTERVALS, continuousIntervals);
            state.u(STATE_CONTINUOUS_FACET_VALUES, [continuousIntervals.effectSize, continuousIntervals.significance]);
        });

        state.ac(STATE_CONTINUOUS_FACET_VALUES, (s, key) => {
            const discreteFilteredLevel = _.cloneDeep(state.g(STATE_DISCRETE_FILTERED));
            state.u(STATE_CONTINUOUS_FILTERED, continuousFacetFilter(discreteFilteredLevel, state.g(STATE_CONTINUOUS_FACET_VALUES)));
        });

        state.ac(STATE_CONTINUOUS_FILTERED, (s, key) => {
            let continuousFilteredLevel = state.g(STATE_CONTINUOUS_FILTERED);
            let chromoIndex = state.g(STATE_ZOOM_CHROMO_INDEX);

            const countIntervals = {
                ccre: levelCountInterval(continuousFilteredLevel, "ccre_intervals", "ccres", chromoIndex),
                gene: levelCountInterval(continuousFilteredLevel, "gene_intervals", "genes", chromoIndex)
            };

            state.u(STATE_COUNT_FILTER_INTERVALS, countIntervals);
            state.u(STATE_COUNT_FILTER_VALUES, [countIntervals.ccre, countIntervals.gene]);
        });

        state.ac(STATE_COUNT_FILTER_VALUES, (s, key) => {
            let continuousFilteredLevel = _.cloneDeep(state.g(STATE_CONTINUOUS_FILTERED));
            state.u(STATE_ALL_FILTERED, countFacetFilter(continuousFilteredLevel, state.g(STATE_COUNT_FILTER_VALUES)));
            render();
        });

        state.ac(STATE_CONTINUOUS_FILTER_INTERVALS, (s, key) => {
            cc(g("chrom-data-continuous-facets"));
            continuousFilterControls().forEach(element => a(g("chrom-data-continuous-facets"), element));
        })

        state.ac(STATE_COUNT_FILTER_INTERVALS, (s, key) => {
            cc(g("chrom-data-counts"));
            countFilterControls().forEach(element => a(g("chrom-data-counts"), element));
        })
    </script>
{% endblock %}
